## Overview

The **Phased Agent Workflow (PAW)** streamlines development of GitHub Copilot chat modes and features by moving work through **staged, reviewable milestones** with **clear artifacts**. PAW separates the lifecycle into **workflow stages** (Specification → Planning → Implementation → Documentation → Integration) and, inside the Implementation stage, **implementation phases** (Phase 1…N) that ship incremental, reviewable PRs.

**Key properties**

* **Traceable** – Every stage produces durable Markdown artifacts committed to Git and reviewed via PRs.
* **Rewindable** – Any stage can restart. If you see the agents are implementing incorrectly, you can always go back to the spec or plan and fix it, and then re-run downstream stages.
* **Agentic** – Purpose‑built chat modes (“agents”) own the work of each stage.
* **Human‑in‑the‑loop** – Humans approve specs/plans, review PRs, and decide when to rewind.
* **Consistent surfaces** – Issues and PRs stay in sync via a lightweight Status agent.

> **Terminology note:** In PAW, **Stages** refer to workflow milestones (e.g., Specification Stage). Within the **Implementation Stage**, work is split into **Implementation Phases** (Phase 1, Phase 2, …) to keep PRs small and reviewable.
> *PAW is staged, and its implementation is phased.*

---

## Repository Layout & Naming

```
/.github/chatmodes                       # chat-mode prompts (final outputs of this work)
  PAW-01A Spec Agent.chatmode.md
  PAW-01B Spec Research Agent.chatmode.md
  PAW-02A Code Research Agent.chatmode.md
  PAW-02B Impl Plan Agent.chatmode.md
  PAW-03A Impl Agent.chatmode.md
  PAW-03B Impl Review Agent.chatmode.md
  PAW-04 Documentation Agent.chatmode.md
  PAW-05 PR Agent.chatmode.md
  PAW-0X Status Agent.chatmode.md

/.paw/work/                     # artifacts created by the PAW process
  <feature-slug>/               # e.g., add-authentication or bugfix-rate-limit
    WorkflowContext.md          # Centralized parameter file (required)
    prompts/
      spec-research.prompt.md   # Optional: generated by Spec Agent if required, refined by developer
      code-research.prompt.md   # Optional: generated if additional code research is needed
    Spec.md    
    SpecResearch.md
    CodeResearch.md
    ImplementationPlan.md
    Docs.md
```

**Feature Slug**: Normalized, filesystem-safe identifier for workflow artifacts (e.g., "auth-system", "api-refactor-v2"). 
Auto-generated from Work Title or GitHub Issue title when not explicitly provided. Remains consistent across branch renames.

**Branching Conventions**

* **Target Branch**: The branch that will hold all completed work. Use your project's naming conventions. E.g. `feature/<slug>` or `user/rde/<slug>`.
* **Planning branch**: `<target_branch>_plan` → used if you prefer a planning PR
* **Implementation phase branches**: `<target_branch>_phase<N>` (or `_phase<M-N>` for ranges)
  * Example for a single phase: `feature/auth_phase1`
  * Example for combining phases 2 and 3: `feature/auth_phase2-3`

**PR Conventions**

* **Planning PR**: `<target_branch>_plan` → `<target_branch>`
* **Phase PRs**: `<target_branch>_phase<N>` → `<target_branch>` (or `<target_branch>_phase<M-N>` → `<target_branch>` for ranges)
* **Docs PR**: `<target_branch>_docs` → `<target_branch>`
* **Final PR**: `<target_branch>` → `main`

## Agents

> The following “agents” are implemented as **Copilot Agent Mode chat modes** in `.github/chatmodes/` using the `PAW-XX` naming scheme.

### Spec Agent

Turns an Issue/brief into a **testable specification** (`Spec.md`) and writes `prompts/spec-research.prompt.md` with open factual questions about the current system plus any optional external/contextual questions that could improve clarity if the human chooses to supply answers manually.

Question types captured in the prompt:
1. **Internal system behavior** (current capabilities, flows, data, constraints) – must be answered for specification completeness.
2. **Optional external/context questions** (e.g., standards, benchmarks, domain considerations) – NOT answered automatically; surfaced so the user may fill them later if helpful.

If there are elements requiring clarification about intent or scope, the agent asks the developer directly and pauses until clarified. It does **not** block on optional external/context questions; the specification proceeds using explicit assumptions where needed.

The Spec Agent focuses strictly on **what the feature must do** (functional / non‑functional requirements, data changes, acceptance criteria) and avoids implementation detail. Success is defined in measurable or observable terms so another agent or reviewer can verify behavior without interpretation.

It creates or checks out the planning branch (`<target_branch>_plan`). It iterates with the developer to eliminate ambiguity. Unanswered optional external/context questions remain in the `SpecResearch.md` manual section and do not prevent finalizing the spec (assumptions are documented where their absence would otherwise create ambiguity).

### Spec Research Agent
Answers the internal system behavior questions in `prompts/spec-research.prompt.md` and produces **factual documentation** in `SpecResearch.md` limited to internal behavioral & structural facts (no code line granularity). It does **not** perform external/web searches. Any external/context questions from the prompt are reproduced verbatim in a "User-Provided External Knowledge" section for manual completion by the user if desired.

This differs from the Code Research Agent, in that it documents how the system behaves today at a conceptual/behavioral level (no file paths) solely for specification clarity. External knowledge is optional and user-supplied only.

The `prompts/spec-research.prompt.md` is initially generated by the Spec Agent; the developer may refine it (adding or removing internal or optional questions) before running research.

The Spec Research Agent creates factual documentation—no design, no improvements, no speculation. It never fabricates external claims or attempt searches; instead it lists any external/context questions untouched for human follow-up.

### Code Research Agent

Maps **where** and **how** the relevant code works today; writes `CodeResearch.md`. 

### Implementation Plan Agent

Creates detailed implementation plans through an interactive, iterative process. Works collaboratively with the developer to produce high-quality technical specifications.

Writes `ImplementationPlan.md` that includes **Implementation Phases**, discrete chunks of work that can be reviewed and merged independently.

### Implementation Agents

The Implementation Agents are split into two chat modes to allow for agentic review and documentation improvements. They handle three scenarios: implementing a phase with new development, responding to review comments on Phase PRs, and responding to review comments on the final PR.

Each **Implementation Phase** is developed on a dedicated branch, runs automated checks, opens Phase PRs, and addresses review comments to completion. For final PR reviews, work occurs directly on the target branch.

#### Implementation Agent

Executes plan phases by making code changes and ensures quality by running automated checks.

When addressing review comments (on phase PRs or final PR), groups related comments into logical units, addresses each group sequentially, and commits each group locally with commit messages that link to the addressed comments. Does not push commits.

For phase work, creates the implementation branch locally if it does not already exist. For final PR reviews, works directly on the target branch. All commits are local only.

#### Implementation Review Agent

- Reviews code changes made by the Implementation Agent, suggests improvements.
- Generates docstrings and code comments for clarity, readability, and maintainability.
- Commits changes with clear, descriptive messages.
- Pushes the implementation branch and opens Phase PRs.

When reviewing addressed comments (on phase PRs or final PR), verifies the Implementation Agent's commits address each comment, adds any needed improvements, pushes all commits, and posts a comprehensive summary comment documenting which review comments were addressed with which commits. Humans use this summary to manually resolve comments in the GitHub UI.

### Documenter Agent

Produces comprehensive documentation in `Docs.md` that serves as the authoritative technical reference for the implemented work (feature, enhancement, bug fix, refactor, etc.). Updates project docs according to project guidance. Opens a docs PR.

The `Docs.md` artifact is detailed, standalone documentation that:
- Explains what was built, how it works, and why design decisions were made
- Documents architecture and design decisions at a high level
- Provides practical guidance on how to use and test the work
- Focuses on concepts and user-facing behavior, not code reproduction
- Serves as the go-to reference for understanding the work
- Can be used as the basis for project-specific documentation generation
- Remains the authoritative reference even in projects without feature-level documentation

### Status Agent

Maintains related Issues and PRs, ensuring links and checklists remain up to date. Run between stages and phases to keep everything in sync.

The Status Agent should be invoked at key milestones:
- After the Planning PR is opened, updated, or merged
- After each Phase PR is opened, updated, or merged
- After the Docs PR is opened, updated, or merged
- After the final PR is opened or merged

It updates the GitHub Issue (if one exists) with current status, links to relevant PRs, and maintains checklists to track progress through the workflow stages and implementation phases.

### PR Agent

Opens the **final PR** from the target branch to `main` and performs comprehensive pre-flight readiness checks to assess completeness.

The PR Agent verifies and reports on prerequisites:
- All implementation phase PRs have been merged to the target branch
- The documentation PR has been merged to the target branch
- All required artifacts exist and are up to date
- The target branch is up to date with the base branch (`main`)

If any pre-flight check fails, the agent reports the status and recommendations. If the user explicitly chooses to proceed, the agent continues.

The agent crafts a comprehensive PR description that includes:
- Summary of the feature or task
- Links to the specification, implementation plan, and documentation
- Links to all merged phase PRs
- Summary of changes and their impact
- Testing and validation evidence
- Any deployment or rollout considerations

The agent creates the final PR and provides guidance on the merge and deployment process.

---

## Stages

Below describes each **Stage** of the PAW process, including agents involved, inputs, outputs, and human workflow.

### Prerequisites

**Inputs:** 

* GitHub Issue if available, otherwise rough brief about the goals of the work.
* A clean branch to track work (e.g., `feature/paw-prompts` or `user/rde/bugfix-123`).

**Human Prerequisite Actions:**

* Create a GitHub Issue if none exists (title, description, links), or write up a brief description of the work that can be pasted into chat.
* Create branch to track work; e.g., `feature/paw-prompts` or `user/rde/bugfix-123`.
* **(Optional)** Create WorkflowContext.md to centralize parameters and eliminate repetition across stages. Refer to the minimal inline format provided in each chatmode instruction for the structure.

**Artifacts:** issue link (optional), branches created, WorkflowContext.md (optional).

---

### Stage 01 - Specification

**Agents:** 

* Spec Agent
* Spec Research Agent

**Inputs**:

* **WorkflowContext.md** (optional): If present at `.paw/work/<feature-slug>/WorkflowContext.md`, provides target branch, GitHub issue, remote, and additional inputs automatically. Otherwise:
  * GitHub Issue link/ID (or brief describing the work)
  * Target branch name (agent can also discover this from the current branch)
  * Any design documents or traditional feature specs that provide additional context for this or a broader set of related work.

**Outputs**:

* `/.paw/work/<feature-slug>/Spec.md`
* `/.paw/work/<feature-slug>/prompts/spec-research.prompt.md`
* `/.paw/work/<feature-slug>/SpecResearch.md` containing System Behavior answers and a "User-Provided External Knowledge" section listing any optional unanswered external/context questions and user-provided context.

**Human Workflow:**

* Ensure a clean and up-to-date feature branch is checked out locally.
* (Optional) If WorkflowContext.md exists, include it in the chat context when invoking the Spec Agent.
* Ask the Spec Agent to draft the spec, providing the Issue link/ID (or brief describing the work), feature branch name, and any hard constraints.
* The Spec Agent will interactively refine the spec with the developer. It will also provide the `spec-research.prompt.md` file with factual questions about the current system.
* Review and refine `spec-research.prompt.md` to add any additional clarifying questions.
* Run the Spec Research Agent to answer the questions in `spec-research.prompt.md` and produce `SpecResearch.md`. If external research tooling is unavailable, fill (or consciously skip) the "External Knowledge" checklist the agent outputs.
* Iterate with the Spec Agent to refine the spec based on findings from `SpecResearch.md`.
* Continue iterating with the above steps until the spec is clear, complete, and testable.

Note the spec will be committed and pushed to the planning branch (`<target_branch>_plan`) at the end of the next stage.

---

### Stage 02 - Implementation Plan

**Agents:**

* Code Research Agent
* Implementation Plan Agent

**Inputs:**

* **WorkflowContext.md** (optional): If present at `.paw/work/<feature-slug>/WorkflowContext.md`, provides target branch, GitHub issue, remote, and artifact paths automatically. Otherwise:
  * Target branch name (agent can also discover this from the current branch)
  * `Spec.md` and `SpecResearch.md` from Stage 01 must be available in the expected location (`/.paw/work/<feature-slug>/`), or have their paths provided.

**Outputs:**
* `/.paw/work/<feature-slug>/CodeResearch.md`
* `/.paw/work/<feature-slug>/ImplementationPlan.md`
* `/.paw/work/<feature-slug>/prompts/code-research.prompt.md` (optional)
* Planning PR opened/updated (`<target_branch>_plan` → `<target_branch>`)

**Human Workflow:**
- Ensure feature branch is checked out locally and updated with merged planning branch.
- (Optional) If WorkflowContext.md exists, include it in the chat context when invoking agents.
- Ask the Code Research Agent to map relevant code areas and dependencies based on the Spec and Spec Research documents, producing `CodeResearch.md`.
- Review `CodeResearch.md` for completeness and accuracy. If necessary, create `prompts/code-research.prompt.md` with guidance and run it with the Code Research Agent to regenerate `CodeResearch.md`.
- Ask the Implementation Plan Agent to draft a detailed implementation plan based on the Spec, Spec Research, and Code Research documents.
- Collaborate with the Implementation Plan Agent to refine the plan and answer open questions.
- If the Implementation Plan Agent makes requests for additional research via edits or creation of `code-research.prompt.md`, run the Code Research Agent as needed.
- Continue iterating with the above steps until the plan is clear, complete, and broken into discrete Implementation Phases.
- The Implementation Plan Agent will open or update the Planning PR with the final output documents from Stage 01 and Stage 02.
- The developer will then review the PR and provide feedback or request changes as needed.
- The developer will ask the Implementation Plan Agent to address any review comments.
- The Implementation Plan Agent will address each comment with focused commits.
- The developer will then review the PR again to ensure all comments have been addressed satisfactorily.
- Once the Planning PR is approved, the developer will merge it and update the local target branch.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue with status and links. This can occur when the Planning PR is opened, updated, or merged.

**Optional Secondary Review:**

- The developer may request another developer to review the Phase PR before merging. That review will be handled the same way as above, with the developer asking the Implementation Agent to address any review comments, and then asking the Implementation Review Agent to review the changes.

---

### Stage 03 — Phased Implementation

**Agents:** 

* Implementation Agent
* Implementation Review Agent

**Inputs:**

* **WorkflowContext.md** (optional): If present, provides target branch, remote, and ImplementationPlan.md path automatically. Otherwise:
  * Target branch name (agent can also discover this from the current branch)
  * `ImplementationPlan.md` from Stage 02 must be available in the expected location (`/.paw/work/<feature-slug>/`), or have its path provided. This provides paths to `Spec.md`, `SpecResearch.md`, along with other related context.
  * The `CodeResearch.md` file.


**Outputs:**

* Phase PRs opened/updated (`<target_branch>_phase<N>` → `<target_branch>`)

**Human Workflow:**

The implementation process follows a cycle for each phase: Implementation Agent makes changes → Implementation Review Agent reviews and enhances → developer reviews PR → address feedback → repeat until approved and merged.

- Ensure the target branch is checked out locally and updated with merged planning branch.
- Ask the Implementation Agent to start implementing the first phase of the plan.
- The Implementation Agent will create and checkout the implementation branch locally if it does not already exist.
- The Implementation Agent will ask clarifying questions as needed. If more information about the current system is required, it may request that the Code Research Agent be run again with an updated prompt, in which case it will create or update `prompts/code-research.prompt.md` and ask the developer to run the Code Research Agent. At that time, the developer should review and refine the prompt to add any additional clarifying questions, and restart the process with the Code Research Agent.
- Once there are no more clarifying questions, the Implementation Agent will proceed to implement the phase.
- The Implementation Agent will run automated checks and ensure they pass.
- Once completed, it will indicate that the local changes are ready for review.
- The developer will then ask the Implementation Review Agent to review the changes made by the Implementation Agent.
- The Implementation Review Agent will review the changes, suggest improvements, generate docstrings and code comments.
- If the suggested changes are approved, the Implementation Review Agent will make those changes.
- Once the review is complete, the Implementation Review Agent will push the changes to the implementation branch and open or update the Phase PR.
- The developer will review the Phase PR and provide feedback or request changes as needed.
- The developer will ask the Implementation Agent to address any review comments.
- The Implementation Agent will first update the local branch from the remote to pull any commits added by reviewers, then read all review comments and determine which still need work (by checking commit history and conversation threads). It groups related comments that need addressing and addresses each group sequentially with focused commits that link to the comments. Commits are made locally only.
- The developer will then ask the Implementation Review Agent to review the changes made by the Implementation Agent.
- The Implementation Review Agent will review each change to ensure it addresses the comments, add any needed improvements, push all commits to the branch, and post a comprehensive summary comment documenting which review comments were addressed with which commits.
- The developer will review the PR, use the summary to manually resolve addressed comments in the GitHub UI, and either approve or request further changes.
- The developer will review the PR again and either approve it or request further changes.
- This process will continue until the Phase PR is approved and ready to merge.
- Once the Phase PR is approved, the developer will merge it and update the local target branch.
- The developer will then ask the Implementation Agent to start implementing the next phase of the plan, and the process repeats until all phases are complete.

**Optional Secondary Review:**
- The developer may request another developer to review the Phase PR before merging. That review will be handled the same way as above, with the developer asking the Implementation Agent to address any review comments, and then asking the Implementation Review Agent to review the changes.

**Flow Diagrams**

Initial Phase Development:
┌─────────────────────────┐
│ Implementation Agent    │ Makes changes, commits locally
│ (Forward Momentum)      │ ↓ Signals ready
└─────────────────────────┘

┌─────────────────────────┐
│ Implementation Review   │ Reviews, adds docs, commits
│ (Quality Gate)          │ ↓ Pushes both commits, opens PR
└─────────────────────────┘

┌─────────────────────────┐
│ Human Review            │
└─────────────────────────┘

Review Comment Follow-up:
┌─────────────────────────┐
│ Implementation Agent    │ Determines which comments need work
│ (Forward Momentum)      │ Groups comments, addresses each group
└─────────────────────────┘ ↓ Commits locally, signals ready

┌─────────────────────────┐
│ Implementation Review   │ Verifies changes, adds improvements
│ (Quality Gate)          │ Pushes all commits
└─────────────────────────┘ ↓ Posts summary of addressed comments

┌─────────────────────────┐
│ Human Re-review         │ Uses summary to resolve comments in UI
└─────────────────────────┘

---

### Stage 04 — Documentation

**Agent:** Documenter Agent

**Inputs:**

* **WorkflowContext.md** (optional): If present, provides target branch, remote, and ImplementationPlan.md path automatically. Otherwise:
  * `ImplementationPlan.md` from Stage 02 must be available in the expected location (`/.paw/work/<feature-slug>/`), or have its path provided. All Phases must be complete and merged to the target branch, with status updated in the plan.
  * All PRs from the implementation phases (agent can search for these or refer to GitHub Issue).

**Outputs:** * `/.paw/work/<feature-slug>/Docs.md` + project specific documentation

**Human Workflow:**
- Ensure the target branch is checked out locally and up to date.
- Ask the Documenter Agent to create documentation, giving references to all relevant inputs. Also provide any specific documentation guidelines or templates that should be followed if not already documented in copilot-instructions.md or other project docs guidance the agent can refer to.
- The Documenter Agent will produce `Docs.md` and open a docs PR (`<target_branch>_docs` → `<target_branch>`).
- The developer will review the docs PR and provide feedback or request changes as needed.
- The developer will ask the Documenter Agent to address any review comments.
- The Documenter Agent will address each comment with focused commits.
- The developer will then review the PR again to ensure all comments have been addressed satisfactorily.
- Once the docs PR is approved, the developer will merge it and update the local target branch.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue with status and links. This can occur when the docs PR is opened, updated, or merged.

---

### Stage 05 — Final PR to `main`

**Agents:** 

* PR Agent
* Implementation Agent
* Implementation Review Agent

**Inputs:**

* **WorkflowContext.md** (optional): If present, provides target branch, remote, and all artifact paths automatically. Otherwise:
  * Target branch name (agent can also discover this from the current branch)
  * All inputs and outputs from the Stage 04 Documentation stage

**Outputs:**

* Final PR opened (`<target_branch>` → `main`)

**Human Workflow:**
- Ensure the target branch is checked out locally and up to date.
- Ask the PR Agent to open the final PR to `main`.
- The PR Agent will craft the PR description, including links to all relevant artifacts and a summary of changes, and create the final PR.
- The developer will review the final PR and provide feedback or request changes as needed.
- If review comments exist:
  - Ask the Implementation Agent to address review comments on the final PR.
  - Ask the Implementation Review Agent to verify changes and reply to reviewers.
  - Repeat until approved.
- Merge the final PR once approved.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue. This can occur when the final PR is opened, updated, or merged.

**Flow Diagram**

Final PR Review Comment Follow-up:
┌─────────────────────────┐
│ Implementation Agent    │ Determines which comments need work
│ (Forward Momentum)      │ Groups comments, addresses on target branch
└─────────────────────────┘ ↓ Commits locally, signals ready

┌─────────────────────────┐
│ Implementation Review   │ Verifies changes, adds improvements
│ (Quality Gate)          │ Pushes all commits
└─────────────────────────┘ ↓ Posts summary of addressed comments

┌─────────────────────────┐
│ Human Re-review         │
└─────────────────────────┘

---

## Artifacts

### Spec.md

The **Specification** is a testable requirements document that defines **what** the feature must do without prescribing **how** to implement it. Created through an interactive process between the Spec Agent and the developer, it serves as the authoritative definition of success for the entire workflow.

**Purpose:** Establish clear, measurable requirements that any agent or human reviewer can use to verify whether an implementation is complete and correct, without guessing or interpreting intent.

**Location:** `/.paw/work/<feature-slug>/Spec.md`

**Dependencies:** Built from a GitHub Issue or project brief, refined through `SpecResearch.md` findings about the current system.

#### Core Principle: What, Not How

The Specification focuses exclusively on requirements and outcomes, avoiding implementation details:

**What it DOES include:**
- Functional requirements (what the feature must do)
- Non-functional requirements (performance, security, usability constraints)
- Data model changes and their business purpose
- User-facing behavior and interactions
- Acceptance criteria that are measurable or observable
- Edge cases and error handling requirements
- Integration points with existing systems (from a behavioral perspective)

**What it does NOT include:**
- Specific file paths or code locations
- Implementation strategies or technical approaches
- Architectural decisions or design patterns
- Database schema details or migration steps
- API endpoint definitions or routing logic

#### Structure & Content

The Specification follows a structured format designed for clarity and testability:

**Header**
- **Feature/Task Name**: Clear, descriptive title
- **Overview**: Brief summary of what the feature accomplishes and why it's needed
- **Context**: Background information, related work, or broader project goals

**Requirements**

**Functional Requirements**
- Numbered list of specific capabilities the feature must provide
- Written as observable behaviors: "The system shall/must..."
- Each requirement is atomic and independently verifiable

**Non-Functional Requirements**
- Performance constraints (response times, throughput, scalability)
- Security requirements (authentication, authorization, data protection)
- Usability requirements (accessibility, user experience)
- Compatibility requirements (browsers, platforms, versions)

**Data Requirements**
- New data entities or attributes needed
- Business rules governing data (validation, relationships, lifecycle)
- Data migration or transformation needs (conceptual, not technical)

**User Experience**
- User workflows and interaction patterns
- Expected behavior in different scenarios
- Error messages and user feedback

**Acceptance Criteria**
- Specific, testable conditions that define "done"
- Written in Given/When/Then format or as verification steps
- Each criterion is independently verifiable
- Covers both happy paths and edge cases

**Example:**
```markdown
### Acceptance Criteria

1. **User Authentication**
   - Given a user with valid credentials
   - When they submit the login form
   - Then they are redirected to the dashboard within 2 seconds
   - And their session persists for 24 hours

2. **Invalid Credentials**
   - Given a user with invalid credentials
   - When they submit the login form
   - Then they see an error message "Invalid username or password"
   - And the form is cleared for retry
   - And no sensitive information is revealed
```

**Out of Scope**
- Explicit list of what this feature will NOT do
- Helps prevent scope creep and clarifies boundaries
- May reference future work or related features

**Open Questions**
- Questions about the current system that require investigation
- Tracked in `prompts/spec-research.prompt.md` for the Spec Research Agent
- This section should be empty in the final spec (all questions resolved)

#### Interactive Creation Process

The Spec Agent creates this document through collaborative iteration:

1. **Initial Draft**: Reads the GitHub Issue/brief and creates first-pass requirements
2. **Clarification**: Questions the developer about ambiguities, gaps, or unclear intent
3. **Research Prompting**: Generates `spec-research.prompt.md` with factual questions about the current system
4. **Research Integration**: Incorporates findings from `SpecResearch.md` to refine requirements
5. **Iteration**: Continues refining based on developer feedback until spec is clear, complete, and testable

The Spec Agent is skeptical and thorough, asking "what about..." and "why" questions to ensure nothing is overlooked.

#### Testability Standard

A critical quality of the Specification is **testability**—every requirement must be verifiable:

- **Measurable**: Uses specific metrics, thresholds, or observable outcomes
- **Observable**: Can be confirmed through testing, inspection, or demonstration
- **Unambiguous**: Has only one reasonable interpretation
- **Complete**: No unstated assumptions or hidden requirements

**Good Example:**
> "The search results must appear within 500ms for queries under 100 characters on datasets up to 1M records."

**Poor Example:**
> "The search should be fast and handle large datasets." (vague, unmeasurable)

#### Relationship to Other Artifacts

- **Spec.md → SpecResearch.md**: Drives factual research questions about current system
- **Spec.md → ImplementationPlan.md**: Defines the "what" that the plan translates into "how"
- **Spec.md → Phase PRs**: Every PR is validated against these acceptance criteria
- **Spec.md → Docs.md**: Documentation explains what was implemented and how it addresses requirements

#### Quality Standards

A well-formed Specification:
- **Is Testable**: Every requirement can be verified objectively
- **Is Complete**: Covers all functional, non-functional, and data requirements
- **Is Clear**: Uses precise language without ambiguity
- **Is Scoped**: Explicitly defines what is and isn't included
- **Is Independent**: Doesn't prescribe implementation approaches
- **Is Collaborative**: Reflects iterative refinement with developer input

### SpecResearch.md

The **Spec Research** document provides factual documentation of how the current system works today, answering specific questions needed to complete the specification. Created by the Spec Research Agent in response to `prompts/spec-research.prompt.md`, it serves as a behavioral and architectural reference without implementation details.

**Purpose:** Answer internal questions about current behavior, components, flows, data concepts, and constraints that the Spec Agent needs to write clear, complete, and accurate requirements. External/context questions are listed for optional manual completion only.

**Location:** `/.paw/work/<feature-slug>/SpecResearch.md`

**Dependencies:** Driven by questions in `prompts/spec-research.prompt.md` (generated by the Spec Agent and optionally refined by the developer). Optional external/context questions are copied into a manual section untouched.

#### Core Principle: Behavioral & Contextual Documentation (Internal + External), Not Implementation Details

The Spec Research document focuses on **what the system does** and **how it behaves** from a user or component perspective, not on code-level implementation:

**What it DOES include:**
- Current system behavior and capabilities (conceptual)
- Component responsibilities and interactions (behavioral description)
- Conceptual data flows (no code paths or schema dumps)
- API or interface behaviors (what they do, not how implemented)
- User-facing workflows & business rules (outcome focused)
- Configuration options and their effects (conceptual)

**What it does NOT include:**
- Specific file paths or line numbers
- Implementation details or code structure
- Database schema or migration details
- Internal function calls or code execution paths
- Technical architecture decisions
- Recommendations for improvements
- Root cause analysis of issues
- Prescriptive selection between external standards (it only cites; selection belongs in specification if required)

**Key Distinction from CodeResearch.md:**
- **SpecResearch.md**: Behavioral view for specification writing ("The authentication system requires email and password and returns a session token")
- **CodeResearch.md**: Implementation view for planning ("Authentication is implemented in `auth/handlers.go:45` using bcrypt for password hashing")

#### Structure & Content

Sections align to prompt internal questions. For each answered question include:
- **Question**
- **Answer** (concise factual behavior)
- **Evidence** (internal references or observation description)
- **Implications** (optional, how it informs spec wording)

At the end, include:
- **User-Provided External Knowledge (Manual Fill)**: Bullet list of any optional external/context questions from the prompt, unchecked and unanswered.
- **Open Unknowns**: Internal questions the agent could not answer (with rationale).

#### Prompting Process
1. Spec Agent generates prompt with internal + optional external/context questions.
2. Developer may refine.
3. Spec Research Agent answers internal questions only.
4. External/context questions are listed for manual fill; user optionally adds content to the SpecResearch.md file before re-running Spec Agent.

#### Research Methodology

The Spec Research Agent searches through and reads the codebase to answer questions:

- **Documentation Review**: Reading existing docs, READMEs, API documentation
- **Code Inspection**: Examining code to understand behavior (not implementation details)
- **Configuration Analysis**: Reviewing config files to understand options and defaults
- **Evidence Citation**: Always backing claims with concrete evidence

The agent focuses on **observable behavior** and **system contracts**, not internal implementation.

#### Relationship to Other Artifacts
- `spec-research.prompt.md → SpecResearch.md`: answers + section for external context
- `SpecResearch.md → Spec.md`: informs requirement drafting
- `Spec.md + SpecResearch.md → CodeResearch.md`: supply behavioral baseline

#### Quality Standards
A well-formed Spec Research document:
- **Is Factual**: Internal truths only; no speculation
- **Is Behavioral**: Describes observable outcomes
- **Is Complete**: Answers all internal questions or lists them as open unknowns + external context asks
- **Is Neutral**: No recommendations or design

### CodeResearch.md

The **Code Research** document provides comprehensive technical mapping of the codebase relevant to the feature or task. Created by the Code Research Agent, it serves as a factual reference documenting **where** components live and **how** they work today, without evaluation or recommendations.

**Purpose:** Create a technical map of the existing system that Implementation Plan Agent can use to design concrete implementation approaches with accurate file paths, patterns, and integration points.

**Location:** `/.paw/work/<feature-slug>/CodeResearch.md`

**Dependencies:** Built upon `Spec.md` and `SpecResearch.md` to focus research on implementation-relevant areas.

#### Core Principle: Documentation, Not Evaluation

**CRITICAL**: The Code Research document is purely descriptive. It documents what exists, where it exists, and how it works—nothing more.

**What it DOES include:**
- Exact file paths and line numbers for relevant code
- Current implementation details and data flows
- Existing patterns and architectural decisions
- Integration points and component interactions
- Test file locations and testing patterns
- Configuration and dependencies

**What it does NOT include:**
- Suggestions for improvements or changes
- Root cause analysis (unless explicitly requested for specification purposes)
- Critique of implementation quality
- Recommendations for refactoring
- Identification of bugs or problems
- Performance evaluations
- Security assessments

#### Structure & Content

The document follows a structured template with YAML frontmatter and organized findings:

**Frontmatter (YAML)**
```yaml
---
date: [ISO format with timezone]
git_commit: [Current commit hash]
branch: [Current branch name]
repository: [Repository name]
topic: "[Research topic/question]"
tags: [research, codebase, relevant-component-names]
status: complete
last_updated: [YYYY-MM-DD]
---
```

**Document Body**
- **Research Question**: The original query or area of investigation
- **Summary**: High-level overview of what was found, answering the research question factually
- **Detailed Findings**: Organized by component/area with:
  - Description of what exists with file:line references
  - How components connect to each other
  - Current implementation details (without evaluation)
- **Code References**: Bulleted list of key file paths with descriptions
- **Architecture Documentation**: Current patterns, conventions, and design implementations found
- **Open Questions**: Areas that need further investigation (if any)

#### Research Methodology

The Code Research Agent follows a systematic approach:

1. **Code Location**: Find WHERE files and components live
   - Search for files by topic/feature using relevant keywords
   - Identify directory patterns and naming conventions
   - Categorize findings (implementation, tests, config, docs, types)
   - Group files by purpose with full paths

2. **Code Analysis**: Understand HOW specific code works
   - Read files to understand logic and identify key functions
   - Trace data flow from entry to exit points
   - Map transformations, validations, and state changes
   - Document architectural patterns and integration points
   - Always include precise file:line references

3. **Code Pattern Finder**: Find examples of existing patterns
   - Locate similar implementations for reference
   - Extract reusable patterns and conventions
   - Provide concrete code examples with file:line references
   - Show multiple variations where they exist

#### GitHub Permalinks

When the commit is pushed or on the main branch, the document includes GitHub permalinks for permanent reference:
- Format: `https://github.com/{owner}/{repo}/blob/{commit}/{file}#L{line}`
- Ensures links remain valid even as code evolves
- **Note**: For private repositories, these links require authentication and will only be accessible to users with appropriate repository access.

#### Follow-up Research

If additional questions arise during planning, the document can be updated:
- Frontmatter updated with `last_updated` and `last_updated_note` fields
- New section added: `## Follow-up Research [timestamp]`
- Additional findings appended to maintain complete research history

#### Quality Standards

A well-formed Code Research document:
- **Is Factual**: Describes only what exists in the codebase today
- **Is Precise**: Includes exact file paths and line numbers for all claims
- **Is Comprehensive**: Covers all relevant components and their interactions
- **Is Organized**: Groups findings logically by component or area
- **Is Traceable**: Provides GitHub permalinks when available
- **Is Neutral**: Documents without critiquing or recommending changes

### ImplementationPlan.md

The **Implementation Plan** is a comprehensive technical specification that translates the high-level requirements from `Spec.md` into actionable, phased development work. Created through an interactive process between the Implementation Plan Agent and the developer, it serves as the definitive blueprint for the Implementation Stage.

**Purpose:** Bridge the gap between "what to build" (Spec) and "how to build it" (Implementation Phases), providing concrete technical guidance that Implementation Agents can execute without ambiguity.

**Location:** `/.paw/work/<feature-slug>/ImplementationPlan.md`

**Dependencies:** Links to and builds upon `Spec.md`, `SpecResearch.md`, and `CodeResearch.md`.

#### Structure & Content

The Implementation Plan follows a standardized template that ensures completeness and actionability:

**Header & Overview**
- **Feature/Task Name**: Clear title matching the specification
- **Overview**: 1-2 sentence summary of what's being implemented and why
- **Current State Analysis**: What exists now, what's missing, key constraints discovered from research
- **Desired End State**: Testable specification of the final state with verification criteria

**Scope Management**
- **Key Discoveries**: Important findings from code research with specific `file:line` references
- **Implementation Approach**: High-level strategy and technical reasoning
- **What We're NOT Doing**: Explicit out-of-scope items to prevent scope creep

**Implementation Phases**
Each phase represents a discrete, reviewable chunk of work that:
- Can be developed on a dedicated branch (`<target_branch>_phase<N>`)
- Produces a standalone Phase PR
- Has clear success criteria (both automated and manual)
- Builds incrementally toward the desired end state

**Phase Structure:**
````markdown
## Phase N: [Descriptive Name]

### Overview
[What this phase accomplishes and why it's sequenced here]

### Changes Required:

#### 1. [Component/File Group]
**File**: `path/to/file.ext`
**Changes**: [Summary of changes]

```[language]
// Specific code to add/modify
```

### Success Criteria:

#### Automated Verification:
- [ ] Migration applies cleanly: `make migrate`
- [ ] Unit tests pass: `make test-component`
- [ ] Type checking passes: `npm run typecheck`
- [ ] Linting passes: `make lint`

#### Manual Verification:
- [ ] Feature works as expected when tested via UI
- [ ] Performance is acceptable under load
- [ ] No regressions in related features

### Status

Unimplemented
````

**Supporting Sections**
- **Testing Strategy**: Unit, integration, and manual testing approaches
- **Performance Considerations**: Any performance implications or optimizations
- **Migration Notes**: How to handle existing data/systems during transitions
- **References**: Links back to source artifacts and similar implementations

#### Success Criteria Philosophy

The plan distinguishes between two types of verification:

1. **Automated Verification**: Commands and checks that Implementation Agents can run independently
   - Build commands, test suites, linting, type checking
   - Specific file existence or content validation
   - API endpoint testing with curl/scripts

2. **Manual Verification**: Human-judgment tasks that require interactive testing
   - UI/UX functionality and user experience
   - Performance under realistic load conditions
   - Edge case handling and error scenarios
   - Cross-browser or cross-platform compatibility

This separation enables Implementation Agents to validate their work automatically while clearly identifying what requires human review.

#### Interactive Creation Process

The Implementation Plan Agent creates this document through a collaborative, iterative process:

1. **Context Gathering**: Reads all prerequisite artifacts completely and performs additional code research
2. **Design Exploration**: Presents multiple technical approaches with trade-offs for human decision
3. **Structure Development**: Proposes phase breakdown and sequencing for validation
4. **Detailed Writing**: Authors the complete plan with specific file paths, code examples, and measurable criteria
5. **Refinement**: Iterates based on feedback until all open questions are resolved

**Critical Requirement**: The final plan must be complete and actionable with zero open questions. If uncertainties arise during planning, the agent pauses to research or request clarification rather than proceeding with ambiguity.

#### Quality Standards

A well-formed Implementation Plan:
- **Is Specific**: Includes exact file paths, function names, and code snippets
- **Is Testable**: Every change has clear, measurable success criteria
- **Is Incremental**: Phases build logically and can be reviewed independently
- **Is Complete**: No technical decisions are deferred or left ambiguous
- **Is Traceable**: Links back to requirements and forward to expected outcomes

The Implementation Plan contains links to `Spec.md`, `SpecResearch.md`, and `CodeResearch.md`.

#### Phase Status Tracking

During implementation, before the Implementation Review Agent pushes changes, it updates the status section of the current phase to reflect progress. It appends any new status section as review iterations occur. It states that the phase is completed and adds any notes that can inform agents working on future phases. It also notes any review tasks for any specific code that reviewers should take a close look at and why.

The status section follows this format:

```markdown
### Status

**State:** Completed | In Progress | Blocked
**Completed:** YYYY-MM-DD
**PR:** #123
**Notes:** [Any relevant notes for future phases]
**Review Focus:** [Specific areas requiring careful review]
```

### Docs.md

The **Documentation** artifact is comprehensive technical documentation of the implemented work (feature, enhancement, bug fix, refactor, etc.). Created by the Documenter Agent, it serves as the authoritative reference for understanding what was built, how it works, and how to use it.

**Purpose:** Provide detailed, standalone documentation that serves as the primary technical reference for engineers and as the source material for any project-specific documentation updates. This is the go-to documentation for anyone needing to understand the work, regardless of whether the project maintains feature-level documentation elsewhere.

**Location:** `/.paw/work/<feature-slug>/Docs.md`

**Dependencies:** Built upon the completed implementation phases, `ImplementationPlan.md`, `Spec.md`, and all merged Phase PRs.

#### Core Principle: Comprehensive Technical Reference

The Docs.md artifact is detailed documentation of the work itself, not a list of documentation changes. It explains what was built, how it works, why design decisions were made, and how to use it—focusing on high-level concepts and user guidance rather than restating code:

**What it DOES include:**
- Comprehensive overview of what was implemented and why
- Architecture and design decisions with rationale
- User-facing functionality and usage patterns
- High-level explanation of key reusable components or APIs (not exhaustive code documentation)
- Configuration options and integration points
- How to test/exercise the work as a human user
- Edge cases, limitations, and error handling (user perspective)
- Practical code examples only when essential to demonstrate usage
- Migration paths and compatibility concerns

**What it does NOT include:**
- Implementation code itself (that's in the codebase)
- Detailed API documentation restating what's in code comments/docstrings
- Internal implementation details already documented in code
- Exhaustive test coverage checklists (tests document themselves)
- Acceptance criteria verification (tracked in implementation artifacts)
- Project documentation updates list (belongs in docs PR description)
- Line-by-line code commentary or unnecessary code reproduction

#### Structure & Content

The document follows a comprehensive format designed to be the authoritative technical reference:

**Overview**
- Summary of what was implemented (feature, enhancement, bug fix, refactor, etc.)
- Purpose and problem being solved
- High-level context and background

**Architecture and Design**
- Architectural overview of the implementation
- Key design decisions and their rationale
- Component interactions and integration points
- Data flow and state management

**User Guide** (when applicable)
- Prerequisites for using the implementation
- Basic usage patterns with examples
- Advanced usage scenarios
- Configuration options and their effects

**Technical Reference** (when applicable)
- High-level overview of reusable components, utilities, or APIs that other parts of the codebase may use
- Focus only on components with external usage—omit internal implementation details
- Conceptual explanation of key behaviors and algorithms (not code-level detail)
- User-facing error conditions, messages, and recovery strategies

**Usage Examples** (when applicable)
- Practical examples showing real-world usage patterns
- Code snippets only when essential to demonstrate user-facing behavior or usage
- Focus on what users need to know, not implementation details

**Testing Guide**
- Step-by-step guide for humans to exercise the feature/fix/enhancement
- For bugs: how to verify the issue is fixed
- For features: how to try out the new functionality
- For enhancements: what changed and how to see the improvements

**Edge Cases and Limitations**
- Known limitations and constraints users should be aware of
- Edge case handling from a user perspective
- Performance considerations

**Migration and Compatibility** (when applicable)
- Migration paths for existing users
- Breaking changes and compatibility notes
- How to handle transitions

#### Relationship to Project Documentation

`Docs.md` serves different purposes depending on project documentation practices:

- **Projects with feature-level documentation**: Docs.md provides detailed source material that can be adapted and integrated into project docs. Project docs may be less detailed or formatted differently.
- **Projects without feature-level documentation**: Docs.md becomes the primary reference documentation that engineers consult to understand the work.
- **All projects**: Docs.md ensures there's always comprehensive documentation of the work, even if project-specific docs are minimal.

#### Quality Standards

A well-formed Docs.md artifact:
- **Is Comprehensive about concepts**: Detailed coverage of design decisions, architecture, and user-facing behavior
- **Is Accurate**: Documentation matches actual implementation
- **Is User-focused**: Written for humans who need to understand and use the work
- **Is Practical**: Emphasizes usage and testing guidance over code details
- **Is Clear**: Understandable without needing to read the implementation
- **Is Concise where appropriate**: References code components rather than reproducing them
- **Is Example-appropriate**: Code examples only when essential to demonstrate usage
- **Is Standalone**: Can be read and understood as the primary technical reference

### WorkflowContext.md

The **Workflow Context** document centralizes workflow parameters (target branch, GitHub issue, remote, artifact paths, Work Title) eliminating repetition across PAW stage invocations.

**Purpose:** Single source of truth for workflow parameters.

**Location:** `/.paw/work/<feature-slug>/WorkflowContext.md`

**Dependencies:** None (agents create/update automatically when invoked)

#### Parameters

**Work Title** (Required after Spec stage)
- 2-4 word descriptive name prefixing all PR titles (e.g., `Auth System`, `API Refactor`)
- Generated by Spec Agent, refined during iterations
- Example: `[Auth System] Phase 1: Database schema and migrations`

**Feature Slug** (Required)
- Normalized identifier for artifact directory (e.g., "auth-system", "api-refactor-v2")
- Auto-generated from Work Title when not provided. Must be unique and filesystem-safe
- Format: lowercase letters, numbers, hyphens only
- Length: 1-100 characters
- Used to construct artifact paths: `.paw/work/<feature-slug>/<Artifact>.md`

**Target Branch** (Required)
- Git branch containing completed work (e.g., "feature/add-authentication")
- Used for git operations and workflow branch naming (`<target_branch>_plan`, `<target_branch>_phase<N>`)

**Remote** (Optional, defaults to `origin`)
- Git remote for branch/PR operations (e.g., `fork`, `upstream`)

**GitHub Issue** (Optional)
- Issue URL for tracking (e.g., `https://github.com/owner/repo/issues/N`)

**Artifact Paths** (Optional, auto-derived)
- Explicit paths for non-standard layouts; defaults to `.paw/work/<feature-slug>/<Artifact>.md`

**Additional Inputs** (Optional)
- Supplementary documents for research (e.g., `paw-specification.md`)

#### Usage

#### Usage

Agents automatically create WorkflowContext.md when first invoked with parameters, or read it from chat context to extract values. Include in context for subsequent stages to avoid re-entering parameters.

---

## Feature Slug

A **Feature Slug** is a normalized, filesystem-safe identifier that serves as the persistent directory name for PAW workflow artifacts.

### Purpose
- Provides human-readable, meaningful directory names (e.g., "user-authentication" instead of "feature/add-auth-backend")
- Remains consistent even if git branches are renamed
- Improves artifact organization and discoverability
- Enables multiple workflows per repository without branch name conflicts

### Generation
Feature Slugs are automatically generated when not explicitly provided:

1. **From Work Title**: If Work Title exists, normalize it to create slug
2. **From GitHub Issue**: If both missing, generate Work Title from Issue title, then generate slug from Work Title
3. **Alignment**: When auto-generating both Work Title and Feature Slug, they derive from same source for consistency

### Normalization Rules
User-provided or auto-generated slugs are normalized:
- Lowercase conversion: "MyFeature" → "myfeature"
- Space replacement: "my feature" → "my-feature"
- Special character removal: "feature (v2)" → "feature-v2"
- Consecutive hyphen collapse: "my--feature" → "my-feature"
- Trim hyphens: "-myfeature-" → "myfeature"
- Maximum length: 100 characters

### Validation
Slugs must meet these requirements:
- Characters: lowercase letters (a-z), numbers (0-9), hyphens (-) only
- Length: 1-100 characters
- Format: no leading/trailing hyphens, no consecutive hyphens
- Uniqueness: no conflicting directory at `.paw/work/<slug>/`
- Reserved names: cannot be ".", "..", "node_modules", ".git", ".paw"

### Conflict Resolution
- **User-provided slug conflict**: Agent prompts user to choose alternative
- **Auto-generated slug conflict**: Agent automatically appends numeric suffix (-2, -3, etc.)

### Examples
| Input | Normalized Slug |
|-------|-----------------|
| "User Authentication System" | user-authentication-system |
| "API Refactor v2" | api-refactor-v2 |
| "Fix: Rate Limit Bug" | fix-rate-limit-bug |
| "my_FEATURE--test" | my-feature-test |
`````