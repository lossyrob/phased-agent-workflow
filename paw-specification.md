## Overview

The **Phased Agent Workflow (PAW)** streamlines development of GitHub Copilot chat modes and features by moving work through **staged, reviewable milestones** with **clear artifacts**. PAW separates the lifecycle into **workflow stages** (Specification → Planning → Implementation → Documentation → Integration) and, inside the Implementation stage, **implementation phases** (Phase 1…N) that ship incremental, reviewable PRs.

**Key properties**

* **Traceable** – Every stage produces durable Markdown artifacts committed to Git and reviewed via PRs.
* **Rewindable** – Any stage can restart. If you see the agents are implementing incorrectly, you can always go back to the spec or plan and fix it, and then re-run downstream stages.
* **Agentic** – Purpose‑built chat modes (“agents”) own the work of each stage.
* **Human‑in‑the‑loop** – Humans approve specs/plans, review PRs, and decide when to rewind.
* **Consistent surfaces** – Issues and PRs stay in sync via a lightweight Status agent.

> **Terminology note:** In PAW, **Stages** refer to workflow milestones (e.g., Specification Stage). Within the **Implementation Stage**, work is split into **Implementation Phases** (Phase 1, Phase 2, …) to keep PRs small and reviewable.
> *PAW is staged, and its implementation is phased.*

---

## Repository Layout & Naming

```
/.github/chatmodes                       # chat-mode prompts (final outputs of this work)
  PAW-01A Spec Agent.chatmode.md
  PAW-01B Spec Research Agent.chatmode.md
  PAW-02A Code Research Agent.chatmode.md
  PAW-02B Impl Plan Agent.chatmode.md
  PAW-03A Impl Agent.chatmode.md
  PAW-03B Impl Review Agent.chatmode.md
  PAW-04 Documentation Agent.chatmode.md
  PAW-05 PR Agent.chatmode.md
  PAW-0X Status Agent.chatmode.md

/docs/agents/                   # artifacts created by the PAW process
  <target_branch>/              # e.g., feature/add-authentication or user/rde/bugfix-123
    prompts/
      spec-research.prompt.md
      code-research.prompt.md
    Spec.md    
    SpecResearch.md
    CodeResearch.md
    ImplementationPlan.md
    Docs.md
```

**Branching conventions**

* **Target Branch**: The branch that will hold all completed work. Use your project's naming conventions. E.g. `feature/<slug>` or `user/rde/<slug>`.
* **Planning branch**: `<target_branch>_plan` → used if you prefer a planning PR
* **Implementation phase branches**: `<target_branch>_phase<N>` (or `_phase<M-N>` for ranges)

**PR conventions**

* **Planning PR**: `<target_branch>_plan` → `<target_branch>`
* **Phase PRs**: `<target_branch>_phase<N>` → `<target_branch>` (or `<target_branch>_phase<M-N>` → `<target_branch>` for ranges)
* **Docs PR**: `<target_branch>_docs` → `<target_branch>`
* **Final PR**: `<target_branch>` → `main`

## Agents

> The following “agents” are implemented as **Copilot Agent Mode chat modes** in `.github/chatmodes/` using the `PAW-XX` naming scheme.

### Spec Agent

Turns an Issue/brief into a **testable specification** (`Spec.md`) and writes `prompts/spec-research.prompt.md` with open factual questions. The developer
iterates with the agent to clarify and refine the spec, and to run the Spec Research Agent when there are open questions that
require knowledge about the current system.

The Spec Agent does not discuss implementation details or specific code locations, but rather focuses on **what the feature must do** 
(functional and non-functional requirements, data changes, acceptance criteria.

The testable specification that is produced should define what success looks like in measurable or observable terms — 
such that another agent (or a human reviewer) could confirm that the implementation satisfies it without guessing or interpreting intent.

The spec agent will create or check out the planning branch (`<target_branch>_plan`).

This agent is tasked with fully understanding the scope of work in the context of a full understanding of the relevant parts of the existing system.
It questions the user to clarify any ambiguities or gaps in the feature description, and iterates with the user until the spec is clear, complete, and testable.

### Spec Research Agent
Answers the  `prompts/spec-research.prompt.md` prompt and produces **factual documentation of the current system** in `SpecResearch.md` (no recommendations).
This differs from the Code Research Agent, in that it does not specify code locations or talk about deep implementation details, but rather
how the system behaves today (components, data flows, APIs, etc) at a level that is useful for the specification generation.

The `prompts/spec-research.prompt.md` is initially generated by the Spec Agent, however the developer should review and refine it to
add their own guidance on clarifying questions that the Spec Research Agent should answer.

This agent is tasked with creating factual, complete documentation of how the current system works today — no design, no improvements, no speculation.
It answers the questions in the prompt thoroughly and completely, citing evidence from the codebase wherever possible.

### Code Research Agent

Maps **where** and **how** the relevant code works today; writes `CodeResearch.md`. 

### Implementation Plan Agent

Creates detailed implementation plans through an interactive, iterative process. Works collaboratively with the user to produce high-quality technical specifications.

Writes `ImplementationPlan.md` that includes **Implementation Phases**, discrete chunks of work that can be reviewed and merged independently.

### Implementation Agents

The Implementation Agents are split into two chat modes to allow for agentic review and documentation improvements.
There are also two scenarios that they handle: implementing a phase with new development and responding to review comments made by humans on the Phase PRs.

Each **Implementation Phase** is developed on a dedicated branch, runs automated checks, opens Phase PRs, and addresses review comments to completion.

#### Implementation Agent

Executes plan phases by making code changes and ensures quality by running automated checks.

If responding to review comments, addresses each comment with focused commits.

Creates the implementation branch locally if it does not already exist.

#### Implementation Review Agent

- Reviews code changes made by the Implementation Agent, suggests improvements.
- Generates docstrings and code comments for clarity, readability, and maintainability.
- Commits changes with clear, descriptive messages.
- Pushes the implementation branch and opens Phase PRs.

If responding to review comments, reviews each change to ensure it addresses the comment, and replies comment-by-comment on the PR. Pushes changes and makes a overall review comment summarizing the changes.

### Documenter Agent

Produces `Docs.md` and updates project docs according to the project guidance. Opens a docs PR.

### Status Scribe

Maintains related Issues and PRs, ensuring links and checklists remain up to date. Run between stages and phases to keep everything in sync.

### PR Agent

Opens the **final PR** from feature → main, performs readiness checks (all Phase PRs merged, docs merged, CI green), and blocks if any pre‑flight fails.

---

## Stages

Below describes each **Stage** of the PAW process, including agents involved, inputs, outputs, and human workflow.

### Prerequisites

**Inputs:** 

* GitHub Issue if available, otherwise rough brief about the goals of the work.
* A clean branch to track work (e.g., `feature/paw-prompts` or `user/rde/bugfix-123`).

**Human Prerequisite Actions:**

* Create a GitHub Issue if none exists (title, description, links), or write up a brief description of the work that can be pasted into chat.
* Create branch to track work; e.g., `feature/paw-prompts` or `user/rde/bugfix-123`.

**Artifacts:** issue link (optional), branches created.

---

### Stage 01 - Specification

**Agents:** 

* Spec Agent
* Spec Research Agent

**Inputs**:

* GitHub Issue link/ID (or brief describing the work)
* Target branch name (agent can also discover this from the current branch)
* Any design documents or traditional feature specs that provide additional context for this or a broader set of related work.

**Outputs**:

* `/docs/agents/<feature_branch>/Spec.md`
* `/docs/agents/<feature_branch>/prompts/spec-research.prompt.md`
* `/docs/agents/<feature_branch>/SpecResearch.md`

**Human Workflow:**

* Ensure a clean and up-to-date feature branch is checked out locally.
* Ask the Spec Agent to draft the spec, providing the Issue link/ID (or brief describing the work), feature branch name, and any hard constraints.
* The Spec Agent will interactively refine the spec with the user. It will also provide the `spec-research.prompt.md` file with factual questions about the current system.
* Review and refine `spec-research.prompt.md` to add any additional clarifying questions.
* Run the Spec Research Agent to answer the questions in `spec-research.prompt.md` and produce `SpecResearch.md`.
* Iterate with the Spec Agent to refine the spec based on findings from `SpecResearch.md`.
* Continue iterating with the above steps until the spec is clear, complete, and testable.

Note the spec will be committed and pushed to the planning branch (`<target_branch>_plan`) at the end of the next stage.

---

### Stage 02 - Implementation Plan

**Agents:**

* Code Research Agent
* Implementation Plan Agent

**Inputs:**

* Target branch name (agent can also discover this from the current branch)
* `Spec.md` and `SpecResearch.md` from Stage 01 must be available in the expected location, or have their paths provided.

**Outputs:**
* `/docs/agents/<feature_branch>/CodeResearch.md`
* `/docs/agents/<feature_branch>/ImplementationPlan.md`
* `/docs/agents/<feature_branch>/prompts/code-research.prompt.md` (optional)
* Planning PR opened/updated (`<target_branch>_plan` → `<target_branch>`)

**Human Workflow:**
- Ensure feature branch is checked out locally and updated with merged planning branch.
- Ask the Code Research Agent to map relevant code areas and dependencies based on the Spec and Spec Research documents, producing `CodeResearch.md`.
- Review `CodeResearch.md` for completeness and accuracy. If necessary, create `prompts/code-research.prompt.md` with guidance and run it with the Code Research Agent to regenerate `CodeResearch.md`.
- Ask the Implementation Plan Agent to draft a detailed implementation plan based on the Spec, Spec Research, and Code Research documents.
- Collaborate with the Implementation Plan Agent to refine the plan and answer open questions.
- If the Implementation Plan Agent makes requests for additional research via edits or creation of `code-research.prompt.md`, run the Code Research Agent as needed.
- Continue iterating with the above steps until the plan is clear, complete, and broken into discrete Implementation Phases.
- The Implementation Plan Agent will open or update the Planning PR with the final output documents from Stage 01 and Stage 02.
- The user will then review the PR and provide feedback or request changes as needed.
- The user will ask the Implementation Plan Agent to address any review comments.
- The Implementation Plan Agent will address each comment with focused commits.
- The user will then review the PR again to ensure all comments have been addressed satisfactorily.
- Once the Planning PR is approved, the user will merge it and update the local target branch.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue with status and links. This can occur when the Planning PR is opened, updated, or merged.

**Optional Secondary Review:**

- The user may request another developer to review the Phase PR before merging. That review will be handled the same way as above, with the user asking the Implementation Agent to address any review comments, and then asking the Implementation Review Agent to review the changes.

---

### Stage 03 — Phased Implementation

**Agents:** 

* Implementation Agent
* Implementation Review Agent

**Inputs:**

* Target branch name (agent can also discover this from the current branch)
* `ImplementationPlan.md` from Stage 02 must be available in the expected location, or have its path provided. This provides paths to `Spec.md`, `SpecResearch.md`, along with other related context.
* The `CodeResearch.md` file.


**Outputs:**

* Phase PRs opened/updated (`<target_branch>_phase<N>` → `<target_branch>`)

**Human Workflow:**
- Ensure the target branch is checked out locally and updated with merged planning branch.
- Ask the Implementation Agent to start implementing the first phase of the plan.
- The Implementation Agent will create and checkout the implementation branch locally if it does not already exist.
- The Implementation Agent will ask clarifying questions as needed. If more information about the current system is required, it may request that the Code Research Agent be run again with an updated prompt, in which case it will create or update `prompts/code-research.prompt.md` and ask the user to run the Code Research Agent. At that time, the user should review and refine the prompt to add any additional clarifying questions, and restart the process with the Code Research Agent.
- Once there are no more clarifying questions, the Implementation Agent will proceed to implement the phase.
- The Implementation Agent will run automated checks and ensure they pass.
- Once completed, it will indicate that the local changes are ready for review.
- The user will then ask the Implementation Review Agent to review the changes made by the Implementation Agent.
- The Implementation Review Agent will review the changes, suggest improvements, generate docstrings and code comments.
- If the suggested changes are approved, the Implementation Review Agent will make those changes.
- Once the review is complete, the Implementation Review Agent will push the changes to the implementation branch and open or update the Phase PR.
- The user will review the Phase PR and provide feedback or request changes as needed.
- The user will ask the Implementation Agent to address any review comments.
- The Implementation Agent will address each comment with focused commits.
- The user will then ask the Implementation Review Agent to review the changes made by the Implementation Agent.
- The Implementation Review Agent will review each change to ensure it addresses the comment, and reply comment-by-comment on the PR.
- Once the review is complete, the Implementation Review Agent will push the changes to the branch and make an overall review comment summarizing the changes.
- The user will review the PR again and either approve it or request further changes.
- This process will continue until the Phase PR is approved and ready to merge.
- Once the Phase PR is approved, the user will merge it and update the local target branch.
- The user will then ask the Implementation Agent to start implementing the next phase of the plan, and the process repeats until all phases are complete.

**Optional Secondary Review:**
- The user may request another developer to review the Phase PR before merging. That review will be handled the same way as above, with the user asking the Implementation Agent to address any review comments, and then asking the Implementation Review Agent to review the changes.

---

### Stage 04 — Documentation

**Agent:** Documenter Agent

**Inputs:**

* `ImplementationPlan.md` from Stage 02 must be available in the expected location, or have its path provided. All Phases must be complete and merged to the target branch, with status updated in the plan.
* All PRs from the implementation phases (agent can search for these or refer to GitHub Issue).

**Outputs:** * `/docs/agents/<feature_branch>/Docs.md` + project specific documentation

**Human Workflow:**
- Ensure the target branch is checked out locally and up to date.
- Ask the Documenter Agent to create documentation, giving references to all relevant inputs. Also provide any specific documentation guidelines or templates that should be followed if not already documented in copilot-instructions.md or other project docs guidance the agent can refer to.
- The Documenter Agent will produce `Docs.md` and open a docs PR (`<target_branch>_docs` → `<target_branch>`).
- The user will review the docs PR and provide feedback or request changes as needed.
- The user will ask the Documenter Agent to address any review comments.
- The Documenter Agent will address each comment with focused commits.
- The user will then review the PR again to ensure all comments have been addressed satisfactorily.
- Once the docs PR is approved, the user will merge it and update the local target branch.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue with status and links. This can occur when the docs PR is opened, updated, or merged.

---

### Stage 05 — Final PR to `main`

**Agent:** 

* PR Agent

**Inputs:**

* Target branch name (agent can also discover this from the current branch)
* All inputs and outputs from the Stage 04 Documentation stage

**Outputs:**

* Final PR opened (`<target_branch>` → `main`)

**Human Workflow:**
- Ensure the target branch is checked out locally and up to date.
- Ask the PR Agent to open the final PR to `main`.
- The PR Agent will craft the PR description, including links to all relevant artifacts and a summary of changes, and create the final PR.

---

## Artifacts

### Spec.md

The **Specification** is a testable requirements document that defines **what** the feature must do without prescribing **how** to implement it. Created through an interactive process between the Spec Agent and the developer, it serves as the authoritative definition of success for the entire workflow.

**Purpose:** Establish clear, measurable requirements that any agent or human reviewer can use to verify whether an implementation is complete and correct, without guessing or interpreting intent.

**Location:** `/docs/agents/<feature_branch>/Spec.md`

**Dependencies:** Built from a GitHub Issue or project brief, refined through `SpecResearch.md` findings about the current system.

#### Core Principle: What, Not How

The Specification focuses exclusively on requirements and outcomes, avoiding implementation details:

**What it DOES include:**
- Functional requirements (what the feature must do)
- Non-functional requirements (performance, security, usability constraints)
- Data model changes and their business purpose
- User-facing behavior and interactions
- Acceptance criteria that are measurable or observable
- Edge cases and error handling requirements
- Integration points with existing systems (from a behavioral perspective)

**What it does NOT include:**
- Specific file paths or code locations
- Implementation strategies or technical approaches
- Architectural decisions or design patterns
- Database schema details or migration steps
- API endpoint definitions or routing logic

#### Structure & Content

The Specification follows a structured format designed for clarity and testability:

**Header**
- **Feature/Task Name**: Clear, descriptive title
- **Overview**: Brief summary of what the feature accomplishes and why it's needed
- **Context**: Background information, related work, or broader project goals

**Requirements**

**Functional Requirements**
- Numbered list of specific capabilities the feature must provide
- Written as observable behaviors: "The system shall/must..."
- Each requirement is atomic and independently verifiable

**Non-Functional Requirements**
- Performance constraints (response times, throughput, scalability)
- Security requirements (authentication, authorization, data protection)
- Usability requirements (accessibility, user experience)
- Compatibility requirements (browsers, platforms, versions)

**Data Requirements**
- New data entities or attributes needed
- Business rules governing data (validation, relationships, lifecycle)
- Data migration or transformation needs (conceptual, not technical)

**User Experience**
- User workflows and interaction patterns
- Expected behavior in different scenarios
- Error messages and user feedback

**Acceptance Criteria**
- Specific, testable conditions that define "done"
- Written in Given/When/Then format or as verification steps
- Each criterion is independently verifiable
- Covers both happy paths and edge cases

**Example:**
```markdown
### Acceptance Criteria

1. **User Authentication**
   - Given a user with valid credentials
   - When they submit the login form
   - Then they are redirected to the dashboard within 2 seconds
   - And their session persists for 24 hours

2. **Invalid Credentials**
   - Given a user with invalid credentials
   - When they submit the login form
   - Then they see an error message "Invalid username or password"
   - And the form is cleared for retry
   - And no sensitive information is revealed
```

**Out of Scope**
- Explicit list of what this feature will NOT do
- Helps prevent scope creep and clarifies boundaries
- May reference future work or related features

**Open Questions**
- Questions about the current system that require investigation
- Tracked in `prompts/spec-research.prompt.md` for the Spec Research Agent
- This section should be empty in the final spec (all questions resolved)

#### Interactive Creation Process

The Spec Agent creates this document through collaborative iteration:

1. **Initial Draft**: Reads the GitHub Issue/brief and creates first-pass requirements
2. **Clarification**: Questions the developer about ambiguities, gaps, or unclear intent
3. **Research Prompting**: Generates `spec-research.prompt.md` with factual questions about the current system
4. **Research Integration**: Incorporates findings from `SpecResearch.md` to refine requirements
5. **Iteration**: Continues refining based on developer feedback until spec is clear, complete, and testable

The Spec Agent is skeptical and thorough, asking "what about..." and "why" questions to ensure nothing is overlooked.

#### Testability Standard

A critical quality of the Specification is **testability**—every requirement must be verifiable:

- **Measurable**: Uses specific metrics, thresholds, or observable outcomes
- **Observable**: Can be confirmed through testing, inspection, or demonstration
- **Unambiguous**: Has only one reasonable interpretation
- **Complete**: No unstated assumptions or hidden requirements

**Good Example:**
> "The search results must appear within 500ms for queries under 100 characters on datasets up to 1M records."

**Poor Example:**
> "The search should be fast and handle large datasets." (vague, unmeasurable)

#### Relationship to Other Artifacts

- **Spec.md → SpecResearch.md**: Drives factual research questions about current system
- **Spec.md → ImplementationPlan.md**: Defines the "what" that the plan translates into "how"
- **Spec.md → Phase PRs**: Every PR is validated against these acceptance criteria
- **Spec.md → Docs.md**: Documentation maps each acceptance criterion to evidence of completion

#### Quality Standards

A well-formed Specification:
- **Is Testable**: Every requirement can be verified objectively
- **Is Complete**: Covers all functional, non-functional, and data requirements
- **Is Clear**: Uses precise language without ambiguity
- **Is Scoped**: Explicitly defines what is and isn't included
- **Is Independent**: Doesn't prescribe implementation approaches
- **Is Collaborative**: Reflects iterative refinement with developer input

### SpecResearch.md

The **Spec Research** document provides factual documentation of how the current system works today, answering specific questions needed to complete the specification. Created by the Spec Research Agent in response to `prompts/spec-research.prompt.md`, it serves as a behavioral and architectural reference without implementation details.

**Purpose:** Answer open questions about the current system's behavior, components, data flows, and APIs that the Spec Agent needs to write clear, complete, and accurate requirements.

**Location:** `/docs/agents/<feature_branch>/SpecResearch.md`

**Dependencies:** Driven by questions in `prompts/spec-research.prompt.md`, which is initially generated by the Spec Agent and refined by the developer.

#### Core Principle: Behavioral Documentation, Not Implementation Details

The Spec Research document focuses on **what the system does** and **how it behaves** from a user or component perspective, not on code-level implementation:

**What it DOES include:**
- Current system behavior and capabilities
- Component responsibilities and interactions
- Data flows between systems (conceptual, not code paths)
- API contracts and interfaces (what they do, not how they're implemented)
- User-facing workflows and patterns
- Business rules and validation logic (outcomes, not code)
- Configuration options and their effects
- Integration points with external systems

**What it does NOT include:**
- Specific file paths or line numbers
- Implementation details or code structure
- Database schema or migration details
- Internal function calls or code execution paths
- Technical architecture decisions
- Recommendations for improvements
- Root cause analysis of issues

**Key Distinction from CodeResearch.md:**
- **SpecResearch.md**: Behavioral view for specification writing ("The authentication system requires email and password and returns a session token")
- **CodeResearch.md**: Implementation view for planning ("Authentication is implemented in `auth/handlers.go:45` using bcrypt for password hashing")

#### Structure & Content

The document answers the specific questions posed in `spec-research.prompt.md`:

**Header**
- Brief introduction explaining what questions are being answered
- Context about why this research was needed

**Research Findings**
Organized by the questions from the prompt, each section includes:

- **Question**: The original question from `spec-research.prompt.md`
- **Answer**: Factual documentation of current behavior
- **Evidence**: Citations from codebase, documentation, or testing
- **Implications**: How this affects the specification

**Example:**
```markdown
### How does the current authentication system work?

**Current Behavior:**
The system supports two authentication methods:
1. Email/password authentication with session-based persistence
2. OAuth integration with Google and GitHub

**Session Management:**
- Sessions expire after 24 hours of inactivity
- Users can have multiple active sessions across devices
- Session revocation is immediate across all services

**Password Requirements:**
- Minimum 8 characters
- Must include uppercase, lowercase, and number
- No special character requirement
- Passwords are not expired/rotated automatically

**Evidence:**
- Login form at `/login` shows both auth options
- Session timeout observed through manual testing
- Password requirements shown in validation messages

**Implications for Spec:**
- New auth features must support both authentication methods
- Session management behavior should remain consistent
- Password policy is established and should not change
```

**Summary**
- High-level takeaways from the research
- Key findings that inform the specification
- Any patterns or conventions that should be followed

#### Prompting Process

The research is driven by a prompt file that the developer can refine:

1. **Initial Generation**: Spec Agent creates `prompts/spec-research.prompt.md` with questions about the current system
2. **Developer Refinement**: Developer reviews and adds/modifies questions for clarity or completeness
3. **Agent Execution**: Spec Research Agent answers each question thoroughly with evidence
4. **Iteration**: If answers are incomplete, the prompt is refined and research is re-run

**Example Prompt Questions:**
```markdown
# Spec Research Prompt

Please research and document the following about the current system:

## Authentication
1. What authentication methods are currently supported?
2. How long do sessions last and how are they managed?
3. What are the password requirements and validation rules?

## User Permissions
1. What roles exist in the system?
2. What permissions does each role have?
3. How are permissions checked and enforced?

## Data Model
1. What user data is currently stored?
2. How are user profiles structured?
3. What fields are required vs optional?
```

#### Research Methodology

The Spec Research Agent uses various methods to answer questions:

- **Documentation Review**: Reading existing docs, READMEs, API documentation
- **Code Inspection**: Examining code to understand behavior (not implementation details)
- **Testing**: Manual interaction with the system to observe behavior
- **Configuration Analysis**: Reviewing config files to understand options and defaults
- **Evidence Citation**: Always backing claims with concrete evidence

The agent focuses on **observable behavior** and **system contracts**, not internal implementation.

#### Relationship to Other Artifacts

- **spec-research.prompt.md → SpecResearch.md**: Prompt drives research execution
- **SpecResearch.md → Spec.md**: Findings inform requirement writing and clarify scope
- **Spec.md + SpecResearch.md → CodeResearch.md**: Together they frame the technical research needed for planning

#### Quality Standards

A well-formed Spec Research document:
- **Is Factual**: Documents only what exists, with evidence
- **Is Behavioral**: Focuses on what the system does, not how code works
- **Is Complete**: Answers all questions from the prompt thoroughly
- **Is Cited**: Backs claims with concrete evidence
- **Is Relevant**: Stays focused on information needed for specification
- **Is Neutral**: No recommendations, improvements, or critiques

### CodeResearch.md

The **Code Research** document provides comprehensive technical mapping of the codebase relevant to the feature or task. Created by the Code Research Agent, it serves as a factual reference documenting **where** components live and **how** they work today, without evaluation or recommendations.

**Purpose:** Create a technical map of the existing system that Implementation Plan Agent can use to design concrete implementation approaches with accurate file paths, patterns, and integration points.

**Location:** `/docs/agents/<feature_branch>/CodeResearch.md`

**Dependencies:** Built upon `Spec.md` and `SpecResearch.md` to focus research on implementation-relevant areas.

#### Core Principle: Documentation, Not Evaluation

**CRITICAL**: The Code Research document is purely descriptive. It documents what exists, where it exists, and how it works—nothing more.

**What it DOES include:**
- Exact file paths and line numbers for relevant code
- Current implementation details and data flows
- Existing patterns and architectural decisions
- Integration points and component interactions
- Test file locations and testing patterns
- Configuration and dependencies

**What it does NOT include:**
- Suggestions for improvements or changes
- Root cause analysis of issues
- Critique of implementation quality
- Recommendations for refactoring
- Identification of bugs or problems
- Performance evaluations
- Security assessments

#### Structure & Content

The document follows a structured template with YAML frontmatter and organized findings:

**Frontmatter (YAML)**
```yaml
---
date: [ISO format with timezone]
git_commit: [Current commit hash]
branch: [Current branch name]
repository: [Repository name]
topic: "[Research topic/question]"
tags: [research, codebase, relevant-component-names]
status: complete
last_updated: [YYYY-MM-DD]
---
```

**Document Body**
- **Research Question**: The original query or area of investigation
- **Summary**: High-level overview of what was found, answering the research question factually
- **Detailed Findings**: Organized by component/area with:
  - Description of what exists with file:line references
  - How components connect to each other
  - Current implementation details (without evaluation)
- **Code References**: Bulleted list of key file paths with descriptions
- **Architecture Documentation**: Current patterns, conventions, and design implementations found
- **Open Questions**: Areas that need further investigation (if any)

#### Research Methodology

The Code Research Agent follows a systematic approach:

1. **Code Location**: Find WHERE files and components live
   - Search for files by topic/feature using relevant keywords
   - Identify directory patterns and naming conventions
   - Categorize findings (implementation, tests, config, docs, types)
   - Group files by purpose with full paths

2. **Code Analysis**: Understand HOW specific code works
   - Read files to understand logic and identify key functions
   - Trace data flow from entry to exit points
   - Map transformations, validations, and state changes
   - Document architectural patterns and integration points
   - Always include precise file:line references

3. **Code Pattern Finder**: Find examples of existing patterns
   - Locate similar implementations for reference
   - Extract reusable patterns and conventions
   - Provide concrete code examples with file:line references
   - Show multiple variations where they exist

#### GitHub Permalinks

When the commit is pushed or on the main branch, the document includes GitHub permalinks for permanent reference:
- Format: `https://github.com/{owner}/{repo}/blob/{commit}/{file}#L{line}`
- Ensures links remain valid even as code evolves

#### Follow-up Research

If additional questions arise during planning, the document can be updated:
- Frontmatter updated with `last_updated` and `last_updated_note` fields
- New section added: `## Follow-up Research [timestamp]`
- Additional findings appended to maintain complete research history

#### Quality Standards

A well-formed Code Research document:
- **Is Factual**: Describes only what exists in the codebase today
- **Is Precise**: Includes exact file paths and line numbers for all claims
- **Is Comprehensive**: Covers all relevant components and their interactions
- **Is Organized**: Groups findings logically by component or area
- **Is Traceable**: Provides GitHub permalinks when available
- **Is Neutral**: Documents without critiquing or recommending changes

### ImplementationPlan.md

The **Implementation Plan** is a comprehensive technical specification that translates the high-level requirements from `Spec.md` into actionable, phased development work. Created through an interactive process between the Implementation Plan Agent and the developer, it serves as the definitive blueprint for the Implementation Stage.

**Purpose:** Bridge the gap between "what to build" (Spec) and "how to build it" (Implementation Phases), providing concrete technical guidance that Implementation Agents can execute without ambiguity.

**Location:** `/docs/agents/<feature_branch>/ImplementationPlan.md`

**Dependencies:** Links to and builds upon `Spec.md`, `SpecResearch.md`, and `CodeResearch.md`.

#### Structure & Content

The Implementation Plan follows a standardized template that ensures completeness and actionability:

**Header & Overview**
- **Feature/Task Name**: Clear title matching the specification
- **Overview**: 1-2 sentence summary of what's being implemented and why
- **Current State Analysis**: What exists now, what's missing, key constraints discovered from research
- **Desired End State**: Testable specification of the final state with verification criteria

**Scope Management**
- **Key Discoveries**: Important findings from code research with specific `file:line` references
- **Implementation Approach**: High-level strategy and technical reasoning
- **What We're NOT Doing**: Explicit out-of-scope items to prevent scope creep

**Implementation Phases**
Each phase represents a discrete, reviewable chunk of work that:
- Can be developed on a dedicated branch (`<target_branch>_phase<N>`)
- Produces a standalone Phase PR
- Has clear success criteria (both automated and manual)
- Builds incrementally toward the desired end state

**Phase Structure:**
````markdown
## Phase N: [Descriptive Name]

### Overview
[What this phase accomplishes and why it's sequenced here]

### Changes Required:

#### 1. [Component/File Group]
**File**: `path/to/file.ext`
**Changes**: [Summary of changes]

```[language]
// Specific code to add/modify
```

### Success Criteria:

#### Automated Verification:
- [ ] Migration applies cleanly: `make migrate`
- [ ] Unit tests pass: `make test-component`
- [ ] Type checking passes: `npm run typecheck`
- [ ] Linting passes: `make lint`

#### Manual Verification:
- [ ] Feature works as expected when tested via UI
- [ ] Performance is acceptable under load
- [ ] No regressions in related features

### Status

Unimplemented
````

**Supporting Sections**
- **Testing Strategy**: Unit, integration, and manual testing approaches
- **Performance Considerations**: Any performance implications or optimizations
- **Migration Notes**: How to handle existing data/systems during transitions
- **References**: Links back to source artifacts and similar implementations

#### Success Criteria Philosophy

The plan distinguishes between two types of verification:

1. **Automated Verification**: Commands and checks that Implementation Agents can run independently
   - Build commands, test suites, linting, type checking
   - Specific file existence or content validation
   - API endpoint testing with curl/scripts

2. **Manual Verification**: Human-judgment tasks that require interactive testing
   - UI/UX functionality and user experience
   - Performance under realistic load conditions
   - Edge case handling and error scenarios
   - Cross-browser or cross-platform compatibility

This separation enables Implementation Agents to validate their work automatically while clearly identifying what requires human review.

#### Interactive Creation Process

The Implementation Plan Agent creates this document through a collaborative, iterative process:

1. **Context Gathering**: Reads all prerequisite artifacts completely and performs additional code research
2. **Design Exploration**: Presents multiple technical approaches with trade-offs for human decision
3. **Structure Development**: Proposes phase breakdown and sequencing for validation
4. **Detailed Writing**: Authors the complete plan with specific file paths, code examples, and measurable criteria
5. **Refinement**: Iterates based on feedback until all open questions are resolved

**Critical Requirement**: The final plan must be complete and actionable with zero open questions. If uncertainties arise during planning, the agent pauses to research or request clarification rather than proceeding with ambiguity.

#### Quality Standards

A well-formed Implementation Plan:
- **Is Specific**: Includes exact file paths, function names, and code snippets
- **Is Testable**: Every change has clear, measurable success criteria
- **Is Incremental**: Phases build logically and can be reviewed independently
- **Is Complete**: No technical decisions are deferred or left ambiguous
- **Is Traceable**: Links back to requirements and forward to expected outcomes

The Implementation Plan contains links to `Spec.md`, `SpecResearch.md`, and `CodeResearch.md`.

#### Phase Status Tracking

During implementation, before the Implementation Review Agent pushes changes, it updates the status section of the current phase to reflect progress. It appends any new status section as review iterations occur. It states that the phase is completed and adds any notes that can inform agents working on future phases. It also notes any review tasks for any specific code that reviewers should take a close look at and why.

### Docs.md

...