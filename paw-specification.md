## Overview

The **Phased Agent Workflow (PAW)** streamlines development of GitHub Copilot chat modes and features by moving work through **staged, reviewable milestones** with **clear artifacts**. PAW separates the lifecycle into **workflow stages** (Specification → Planning → Implementation → Documentation → Integration) and, inside the Implementation stage, **implementation phases** (Phase 1…N) that ship incremental, reviewable PRs.

**Key properties**

* **Traceable** – Every stage produces durable Markdown artifacts committed to Git and reviewed via PRs.
* **Rewindable** – Any stage can restart. If you see the agents are implementing incorrectly, you can always go back to the spec or plan and fix it, and then re-run downstream stages.
* **Agentic** – Purpose‑built chat modes (“agents”) own the work of each stage.
* **Human‑in‑the‑loop** – Humans approve specs/plans, review PRs, and decide when to rewind.
* **Consistent surfaces** – Issues and PRs stay in sync via a lightweight Status agent.

> **Terminology note:** In PAW, **Stages** refer to workflow milestones (e.g., Specification Stage). Within the **Implementation Stage**, work is split into **Implementation Phases** (Phase 1, Phase 2, …) to keep PRs small and reviewable.
> *PAW is staged, and its implementation is phased.*

---

## Repository Layout & Naming

```
/.github/chatmodes                       # chat-mode prompts (final outputs of this work)
  PAW-01A Spec Agent.chatmode.md
  PAW-01B Spec Research Agent.chatmode.md
  PAW-02A Code Research Agent.chatmode.md
  PAW-02B Impl Plan Agent.chatmode.md
  PAW-03A Impl Agent.chatmode.md
  PAW-03B Impl Review Agent.chatmode.md
  PAW-04 Documentation Agent.chatmode.md
  PAW-05 PR Agent.chatmode.md
  PAW-0X Status Agent.chatmode.md

/docs/agents/                   # artifacts created by the PAW process
  <target_branch>/              # e.g., feature/add-authentication or user/rde/bugfix-123
    prompts/
      spec-research.prompt.md   # Optional: generated by Spec Agent if required, refined by developer
      code-research.prompt.md   # Optional: generated if additional code research is needed
    Spec.md    
    SpecResearch.md
    CodeResearch.md
    ImplementationPlan.md
    Docs.md
```

**Branching Conventions**

* **Target Branch**: The branch that will hold all completed work. Use your project's naming conventions. E.g. `feature/<slug>` or `user/rde/<slug>`.
* **Planning branch**: `<target_branch>_plan` → used if you prefer a planning PR
* **Implementation phase branches**: `<target_branch>_phase<N>` (or `_phase<M-N>` for ranges)
  * Example for a single phase: `feature/auth_phase1`
  * Example for combining phases 2 and 3: `feature/auth_phase2-3`

**PR Conventions**

* **Planning PR**: `<target_branch>_plan` → `<target_branch>`
* **Phase PRs**: `<target_branch>_phase<N>` → `<target_branch>` (or `<target_branch>_phase<M-N>` → `<target_branch>` for ranges)
* **Docs PR**: `<target_branch>_docs` → `<target_branch>`
* **Final PR**: `<target_branch>` → `main`

## Agents

> The following “agents” are implemented as **Copilot Agent Mode chat modes** in `.github/chatmodes/` using the `PAW-XX` naming scheme.

### Spec Agent

Turns an Issue/brief into a **testable specification** (`Spec.md`) and writes `prompts/spec-research.prompt.md` with open factual questions about the current system plus any optional external/contextual questions that could improve clarity if the human chooses to supply answers manually.

Question types captured in the prompt:
1. **Internal system behavior** (current capabilities, flows, data, constraints) – must be answered for specification completeness.
2. **Optional external/context questions** (e.g., standards, benchmarks, domain considerations) – NOT answered automatically; surfaced so the user may fill them later if helpful.

If there are elements requiring clarification about intent or scope, the agent asks the developer directly and pauses until clarified. It does **not** block on optional external/context questions; the specification proceeds using explicit assumptions where needed.

The Spec Agent focuses strictly on **what the feature must do** (functional / non‑functional requirements, data changes, acceptance criteria) and avoids implementation detail. Success is defined in measurable or observable terms so another agent or reviewer can verify behavior without interpretation.

It creates or checks out the planning branch (`<target_branch>_plan`). It iterates with the developer to eliminate ambiguity. Unanswered optional external/context questions remain in the `SpecResearch.md` manual section and do not prevent finalizing the spec (assumptions are documented where their absence would otherwise create ambiguity).

### Spec Research Agent
Answers the internal system behavior questions in `prompts/spec-research.prompt.md` and produces **factual documentation** in `SpecResearch.md` limited to internal behavioral & structural facts (no code line granularity). It does **not** perform external/web searches. Any external/context questions from the prompt are reproduced verbatim in a "User-Provided External Knowledge" section for manual completion by the user if desired.

This differs from the Code Research Agent, in that it documents how the system behaves today at a conceptual/behavioral level (no file paths) solely for specification clarity. External knowledge is optional and user-supplied only.

The `prompts/spec-research.prompt.md` is initially generated by the Spec Agent; the developer may refine it (adding or removing internal or optional questions) before running research.

The Spec Research Agent creates factual documentation—no design, no improvements, no speculation. It never fabricates external claims or attempt searches; instead it lists any external/context questions untouched for human follow-up.

### Code Research Agent

Maps **where** and **how** the relevant code works today; writes `CodeResearch.md`. 

### Implementation Plan Agent

Creates detailed implementation plans through an interactive, iterative process. Works collaboratively with the developer to produce high-quality technical specifications.

Writes `ImplementationPlan.md` that includes **Implementation Phases**, discrete chunks of work that can be reviewed and merged independently.

### Implementation Agents

The Implementation Agents are split into two chat modes to allow for agentic review and documentation improvements.
There are also two scenarios that they handle: implementing a phase with new development and responding to review comments made by humans on the Phase PRs.

Each **Implementation Phase** is developed on a dedicated branch, runs automated checks, opens Phase PRs, and addresses review comments to completion.

#### Implementation Agent

Executes plan phases by making code changes and ensures quality by running automated checks.

If responding to review comments, addresses each comment with focused commits.

Creates the implementation branch locally if it does not already exist.

#### Implementation Review Agent

- Reviews code changes made by the Implementation Agent, suggests improvements.
- Generates docstrings and code comments for clarity, readability, and maintainability.
- Commits changes with clear, descriptive messages.
- Pushes the implementation branch and opens Phase PRs.

If responding to review comments, reviews each change to ensure it addresses the comment, and replies comment-by-comment on the PR. Pushes changes and makes a overall review comment summarizing the changes.

### Documenter Agent

Produces `Docs.md` and updates project docs according to the project guidance. Opens a docs PR.

### Status Agent

Maintains related Issues and PRs, ensuring links and checklists remain up to date. Run between stages and phases to keep everything in sync.

The Status Agent should be invoked at key milestones:
- After the Planning PR is opened, updated, or merged
- After each Phase PR is opened, updated, or merged
- After the Docs PR is opened, updated, or merged
- After the final PR is opened or merged

It updates the GitHub Issue (if one exists) with current status, links to relevant PRs, and maintains checklists to track progress through the workflow stages and implementation phases.

### PR Agent

Opens the **final PR** from the target branch to `main` and performs comprehensive pre-flight readiness checks before allowing the PR to be created.

The PR Agent validates that all prerequisites are complete:
- All implementation phase PRs have been merged to the target branch
- The documentation PR has been merged to the target branch
- All required artifacts exist and are up to date
- The target branch is up to date with the base branch (`main`)

If any pre-flight check fails, the agent blocks PR creation and provides clear guidance on what must be completed first.

Once all checks pass, the agent crafts a comprehensive PR description that includes:
- Summary of the feature or task
- Links to the specification, implementation plan, and documentation
- Links to all merged phase PRs
- Summary of changes and their impact
- Testing and validation evidence
- Any deployment or rollout considerations

The agent creates the final PR and provides guidance on the merge and deployment process.

---

## Stages

Below describes each **Stage** of the PAW process, including agents involved, inputs, outputs, and human workflow.

### Prerequisites

**Inputs:** 

* GitHub Issue if available, otherwise rough brief about the goals of the work.
* A clean branch to track work (e.g., `feature/paw-prompts` or `user/rde/bugfix-123`).

**Human Prerequisite Actions:**

* Create a GitHub Issue if none exists (title, description, links), or write up a brief description of the work that can be pasted into chat.
* Create branch to track work; e.g., `feature/paw-prompts` or `user/rde/bugfix-123`.

**Artifacts:** issue link (optional), branches created.

---

### Stage 01 - Specification

**Agents:** 

* Spec Agent
* Spec Research Agent

**Inputs**:

* GitHub Issue link/ID (or brief describing the work)
* Target branch name (agent can also discover this from the current branch)
* Any design documents or traditional feature specs that provide additional context for this or a broader set of related work.

**Outputs**:

* `/docs/agents/<target_branch>/Spec.md`
* `/docs/agents/<target_branch>/prompts/spec-research.prompt.md`
* `/docs/agents/<target_branch>/SpecResearch.md` containing System Behavior answers and a "User-Provided External Knowledge" section listing any optional unanswered external/context questions and user-provided context.

**Human Workflow:**

* Ensure a clean and up-to-date feature branch is checked out locally.
* Ask the Spec Agent to draft the spec, providing the Issue link/ID (or brief describing the work), feature branch name, and any hard constraints.
* The Spec Agent will interactively refine the spec with the developer. It will also provide the `spec-research.prompt.md` file with factual questions about the current system.
* Review and refine `spec-research.prompt.md` to add any additional clarifying questions.
* Run the Spec Research Agent to answer the questions in `spec-research.prompt.md` and produce `SpecResearch.md`. If external research tooling is unavailable, fill (or consciously skip) the "External Knowledge" checklist the agent outputs.
* Iterate with the Spec Agent to refine the spec based on findings from `SpecResearch.md`.
* Continue iterating with the above steps until the spec is clear, complete, and testable.

Note the spec will be committed and pushed to the planning branch (`<target_branch>_plan`) at the end of the next stage.

---

### Stage 02 - Implementation Plan

**Agents:**

* Code Research Agent
* Implementation Plan Agent

**Inputs:**

* Target branch name (agent can also discover this from the current branch)
* `Spec.md` and `SpecResearch.md` from Stage 01 must be available in the expected location (`/docs/agents/<target_branch>/`), or have their paths provided.

**Outputs:**
* `/docs/agents/<target_branch>/CodeResearch.md`
* `/docs/agents/<target_branch>/ImplementationPlan.md`
* `/docs/agents/<target_branch>/prompts/code-research.prompt.md` (optional)
* Planning PR opened/updated (`<target_branch>_plan` → `<target_branch>`)

**Human Workflow:**
- Ensure feature branch is checked out locally and updated with merged planning branch.
- Ask the Code Research Agent to map relevant code areas and dependencies based on the Spec and Spec Research documents, producing `CodeResearch.md`.
- Review `CodeResearch.md` for completeness and accuracy. If necessary, create `prompts/code-research.prompt.md` with guidance and run it with the Code Research Agent to regenerate `CodeResearch.md`.
- Ask the Implementation Plan Agent to draft a detailed implementation plan based on the Spec, Spec Research, and Code Research documents.
- Collaborate with the Implementation Plan Agent to refine the plan and answer open questions.
- If the Implementation Plan Agent makes requests for additional research via edits or creation of `code-research.prompt.md`, run the Code Research Agent as needed.
- Continue iterating with the above steps until the plan is clear, complete, and broken into discrete Implementation Phases.
- The Implementation Plan Agent will open or update the Planning PR with the final output documents from Stage 01 and Stage 02.
- The developer will then review the PR and provide feedback or request changes as needed.
- The developer will ask the Implementation Plan Agent to address any review comments.
- The Implementation Plan Agent will address each comment with focused commits.
- The developer will then review the PR again to ensure all comments have been addressed satisfactorily.
- Once the Planning PR is approved, the developer will merge it and update the local target branch.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue with status and links. This can occur when the Planning PR is opened, updated, or merged.

**Optional Secondary Review:**

- The developer may request another developer to review the Phase PR before merging. That review will be handled the same way as above, with the developer asking the Implementation Agent to address any review comments, and then asking the Implementation Review Agent to review the changes.

---

### Stage 03 — Phased Implementation

**Agents:** 

* Implementation Agent
* Implementation Review Agent

**Inputs:**

* Target branch name (agent can also discover this from the current branch)
* `ImplementationPlan.md` from Stage 02 must be available in the expected location (`/docs/agents/<target_branch>/`), or have its path provided. This provides paths to `Spec.md`, `SpecResearch.md`, along with other related context.
* The `CodeResearch.md` file.


**Outputs:**

* Phase PRs opened/updated (`<target_branch>_phase<N>` → `<target_branch>`)

**Human Workflow:**

The implementation process follows a cycle for each phase: Implementation Agent makes changes → Implementation Review Agent reviews and enhances → developer reviews PR → address feedback → repeat until approved and merged.

- Ensure the target branch is checked out locally and updated with merged planning branch.
- Ask the Implementation Agent to start implementing the first phase of the plan.
- The Implementation Agent will create and checkout the implementation branch locally if it does not already exist.
- The Implementation Agent will ask clarifying questions as needed. If more information about the current system is required, it may request that the Code Research Agent be run again with an updated prompt, in which case it will create or update `prompts/code-research.prompt.md` and ask the developer to run the Code Research Agent. At that time, the developer should review and refine the prompt to add any additional clarifying questions, and restart the process with the Code Research Agent.
- Once there are no more clarifying questions, the Implementation Agent will proceed to implement the phase.
- The Implementation Agent will run automated checks and ensure they pass.
- Once completed, it will indicate that the local changes are ready for review.
- The developer will then ask the Implementation Review Agent to review the changes made by the Implementation Agent.
- The Implementation Review Agent will review the changes, suggest improvements, generate docstrings and code comments.
- If the suggested changes are approved, the Implementation Review Agent will make those changes.
- Once the review is complete, the Implementation Review Agent will push the changes to the implementation branch and open or update the Phase PR.
- The developer will review the Phase PR and provide feedback or request changes as needed.
- The developer will ask the Implementation Agent to address any review comments.
- The Implementation Agent will address each comment with focused commits.
- The developer will then ask the Implementation Review Agent to review the changes made by the Implementation Agent.
- The Implementation Review Agent will review each change to ensure it addresses the comment, and reply comment-by-comment on the PR.
- Once the review is complete, the Implementation Review Agent will push the changes to the branch and make an overall review comment summarizing the changes.
- The developer will review the PR again and either approve it or request further changes.
- This process will continue until the Phase PR is approved and ready to merge.
- Once the Phase PR is approved, the developer will merge it and update the local target branch.
- The developer will then ask the Implementation Agent to start implementing the next phase of the plan, and the process repeats until all phases are complete.

**Optional Secondary Review:**
- The developer may request another developer to review the Phase PR before merging. That review will be handled the same way as above, with the developer asking the Implementation Agent to address any review comments, and then asking the Implementation Review Agent to review the changes.

---

### Stage 04 — Documentation

**Agent:** Documenter Agent

**Inputs:**

* `ImplementationPlan.md` from Stage 02 must be available in the expected location (`/docs/agents/<target_branch>/`), or have its path provided. All Phases must be complete and merged to the target branch, with status updated in the plan.
* All PRs from the implementation phases (agent can search for these or refer to GitHub Issue).

**Outputs:** * `/docs/agents/<target_branch>/Docs.md` + project specific documentation

**Human Workflow:**
- Ensure the target branch is checked out locally and up to date.
- Ask the Documenter Agent to create documentation, giving references to all relevant inputs. Also provide any specific documentation guidelines or templates that should be followed if not already documented in copilot-instructions.md or other project docs guidance the agent can refer to.
- The Documenter Agent will produce `Docs.md` and open a docs PR (`<target_branch>_docs` → `<target_branch>`).
- The developer will review the docs PR and provide feedback or request changes as needed.
- The developer will ask the Documenter Agent to address any review comments.
- The Documenter Agent will address each comment with focused commits.
- The developer will then review the PR again to ensure all comments have been addressed satisfactorily.
- Once the docs PR is approved, the developer will merge it and update the local target branch.
- If tracking with a GitHub Issue, use the Status Agent to update the Issue with status and links. This can occur when the docs PR is opened, updated, or merged.

---

### Stage 05 — Final PR to `main`

**Agent:** 

* PR Agent

**Inputs:**

* Target branch name (agent can also discover this from the current branch)
* All inputs and outputs from the Stage 04 Documentation stage

**Outputs:**

* Final PR opened (`<target_branch>` → `main`)

**Human Workflow:**
- Ensure the target branch is checked out locally and up to date.
- Ask the PR Agent to open the final PR to `main`.
- The PR Agent will craft the PR description, including links to all relevant artifacts and a summary of changes, and create the final PR.

---

## Artifacts

### Spec.md

The **Specification** is a testable requirements document that defines **what** the feature must do without prescribing **how** to implement it. Created through an interactive process between the Spec Agent and the developer, it serves as the authoritative definition of success for the entire workflow.

**Purpose:** Establish clear, measurable requirements that any agent or human reviewer can use to verify whether an implementation is complete and correct, without guessing or interpreting intent.

**Location:** `/docs/agents/<target_branch>/Spec.md`

**Dependencies:** Built from a GitHub Issue or project brief, refined through `SpecResearch.md` findings about the current system.

#### Core Principle: What, Not How

The Specification focuses exclusively on requirements and outcomes, avoiding implementation details:

**What it DOES include:**
- Functional requirements (what the feature must do)
- Non-functional requirements (performance, security, usability constraints)
- Data model changes and their business purpose
- User-facing behavior and interactions
- Acceptance criteria that are measurable or observable
- Edge cases and error handling requirements
- Integration points with existing systems (from a behavioral perspective)

**What it does NOT include:**
- Specific file paths or code locations
- Implementation strategies or technical approaches
- Architectural decisions or design patterns
- Database schema details or migration steps
- API endpoint definitions or routing logic

#### Structure & Content

The Specification follows a structured format designed for clarity and testability:

**Header**
- **Feature/Task Name**: Clear, descriptive title
- **Overview**: Brief summary of what the feature accomplishes and why it's needed
- **Context**: Background information, related work, or broader project goals

**Requirements**

**Functional Requirements**
- Numbered list of specific capabilities the feature must provide
- Written as observable behaviors: "The system shall/must..."
- Each requirement is atomic and independently verifiable

**Non-Functional Requirements**
- Performance constraints (response times, throughput, scalability)
- Security requirements (authentication, authorization, data protection)
- Usability requirements (accessibility, user experience)
- Compatibility requirements (browsers, platforms, versions)

**Data Requirements**
- New data entities or attributes needed
- Business rules governing data (validation, relationships, lifecycle)
- Data migration or transformation needs (conceptual, not technical)

**User Experience**
- User workflows and interaction patterns
- Expected behavior in different scenarios
- Error messages and user feedback

**Acceptance Criteria**
- Specific, testable conditions that define "done"
- Written in Given/When/Then format or as verification steps
- Each criterion is independently verifiable
- Covers both happy paths and edge cases

**Example:**
```markdown
### Acceptance Criteria

1. **User Authentication**
   - Given a user with valid credentials
   - When they submit the login form
   - Then they are redirected to the dashboard within 2 seconds
   - And their session persists for 24 hours

2. **Invalid Credentials**
   - Given a user with invalid credentials
   - When they submit the login form
   - Then they see an error message "Invalid username or password"
   - And the form is cleared for retry
   - And no sensitive information is revealed
```

**Out of Scope**
- Explicit list of what this feature will NOT do
- Helps prevent scope creep and clarifies boundaries
- May reference future work or related features

**Open Questions**
- Questions about the current system that require investigation
- Tracked in `prompts/spec-research.prompt.md` for the Spec Research Agent
- This section should be empty in the final spec (all questions resolved)

#### Interactive Creation Process

The Spec Agent creates this document through collaborative iteration:

1. **Initial Draft**: Reads the GitHub Issue/brief and creates first-pass requirements
2. **Clarification**: Questions the developer about ambiguities, gaps, or unclear intent
3. **Research Prompting**: Generates `spec-research.prompt.md` with factual questions about the current system
4. **Research Integration**: Incorporates findings from `SpecResearch.md` to refine requirements
5. **Iteration**: Continues refining based on developer feedback until spec is clear, complete, and testable

The Spec Agent is skeptical and thorough, asking "what about..." and "why" questions to ensure nothing is overlooked.

#### Testability Standard

A critical quality of the Specification is **testability**—every requirement must be verifiable:

- **Measurable**: Uses specific metrics, thresholds, or observable outcomes
- **Observable**: Can be confirmed through testing, inspection, or demonstration
- **Unambiguous**: Has only one reasonable interpretation
- **Complete**: No unstated assumptions or hidden requirements

**Good Example:**
> "The search results must appear within 500ms for queries under 100 characters on datasets up to 1M records."

**Poor Example:**
> "The search should be fast and handle large datasets." (vague, unmeasurable)

#### Relationship to Other Artifacts

- **Spec.md → SpecResearch.md**: Drives factual research questions about current system
- **Spec.md → ImplementationPlan.md**: Defines the "what" that the plan translates into "how"
- **Spec.md → Phase PRs**: Every PR is validated against these acceptance criteria
- **Spec.md → Docs.md**: Documentation maps each acceptance criterion to evidence of completion

#### Quality Standards

A well-formed Specification:
- **Is Testable**: Every requirement can be verified objectively
- **Is Complete**: Covers all functional, non-functional, and data requirements
- **Is Clear**: Uses precise language without ambiguity
- **Is Scoped**: Explicitly defines what is and isn't included
- **Is Independent**: Doesn't prescribe implementation approaches
- **Is Collaborative**: Reflects iterative refinement with developer input

### SpecResearch.md

The **Spec Research** document provides factual documentation of how the current system works today, answering specific questions needed to complete the specification. Created by the Spec Research Agent in response to `prompts/spec-research.prompt.md`, it serves as a behavioral and architectural reference without implementation details.

**Purpose:** Answer internal questions about current behavior, components, flows, data concepts, and constraints that the Spec Agent needs to write clear, complete, and accurate requirements. External/context questions are listed for optional manual completion only.

**Location:** `/docs/agents/<target_branch>/SpecResearch.md`

**Dependencies:** Driven by questions in `prompts/spec-research.prompt.md` (generated by the Spec Agent and optionally refined by the developer). Optional external/context questions are copied into a manual section untouched.

#### Core Principle: Behavioral & Contextual Documentation (Internal + External), Not Implementation Details

The Spec Research document focuses on **what the system does** and **how it behaves** from a user or component perspective, not on code-level implementation:

**What it DOES include:**
- Current system behavior and capabilities (conceptual)
- Component responsibilities and interactions (behavioral description)
- Conceptual data flows (no code paths or schema dumps)
- API or interface behaviors (what they do, not how implemented)
- User-facing workflows & business rules (outcome focused)
- Configuration options and their effects (conceptual)

**What it does NOT include:**
- Specific file paths or line numbers
- Implementation details or code structure
- Database schema or migration details
- Internal function calls or code execution paths
- Technical architecture decisions
- Recommendations for improvements
- Root cause analysis of issues
- Prescriptive selection between external standards (it only cites; selection belongs in specification if required)

**Key Distinction from CodeResearch.md:**
- **SpecResearch.md**: Behavioral view for specification writing ("The authentication system requires email and password and returns a session token")
- **CodeResearch.md**: Implementation view for planning ("Authentication is implemented in `auth/handlers.go:45` using bcrypt for password hashing")

#### Structure & Content

Sections align to prompt internal questions. For each answered question include:
- **Question**
- **Answer** (concise factual behavior)
- **Evidence** (internal references or observation description)
- **Implications** (optional, how it informs spec wording)

At the end, include:
- **User-Provided External Knowledge (Manual Fill)**: Bullet list of any optional external/context questions from the prompt, unchecked and unanswered.
- **Open Unknowns**: Internal questions the agent could not answer (with rationale).

#### Prompting Process
1. Spec Agent generates prompt with internal + optional external/context questions.
2. Developer may refine.
3. Spec Research Agent answers internal questions only.
4. External/context questions are listed for manual fill; user optionally adds content to the SpecResearch.md file before re-running Spec Agent.

#### Research Methodology

The Spec Research Agent searches through and reads the codebase to answer questions:

- **Documentation Review**: Reading existing docs, READMEs, API documentation
- **Code Inspection**: Examining code to understand behavior (not implementation details)
- **Configuration Analysis**: Reviewing config files to understand options and defaults
- **Evidence Citation**: Always backing claims with concrete evidence

The agent focuses on **observable behavior** and **system contracts**, not internal implementation.

#### Relationship to Other Artifacts
- `spec-research.prompt.md → SpecResearch.md`: answers + section for external context
- `SpecResearch.md → Spec.md`: informs requirement drafting
- `Spec.md + SpecResearch.md → CodeResearch.md`: supply behavioral baseline

#### Quality Standards
A well-formed Spec Research document:
- **Is Factual**: Internal truths only; no speculation
- **Is Behavioral**: Describes observable outcomes
- **Is Complete**: Answers all internal questions or lists them as open unknowns + external context asks
- **Is Neutral**: No recommendations or design

### CodeResearch.md

The **Code Research** document provides comprehensive technical mapping of the codebase relevant to the feature or task. Created by the Code Research Agent, it serves as a factual reference documenting **where** components live and **how** they work today, without evaluation or recommendations.

**Purpose:** Create a technical map of the existing system that Implementation Plan Agent can use to design concrete implementation approaches with accurate file paths, patterns, and integration points.

**Location:** `/docs/agents/<target_branch>/CodeResearch.md`

**Dependencies:** Built upon `Spec.md` and `SpecResearch.md` to focus research on implementation-relevant areas.

#### Core Principle: Documentation, Not Evaluation

**CRITICAL**: The Code Research document is purely descriptive. It documents what exists, where it exists, and how it works—nothing more.

**What it DOES include:**
- Exact file paths and line numbers for relevant code
- Current implementation details and data flows
- Existing patterns and architectural decisions
- Integration points and component interactions
- Test file locations and testing patterns
- Configuration and dependencies

**What it does NOT include:**
- Suggestions for improvements or changes
- Root cause analysis (unless explicitly requested for specification purposes)
- Critique of implementation quality
- Recommendations for refactoring
- Identification of bugs or problems
- Performance evaluations
- Security assessments

#### Structure & Content

The document follows a structured template with YAML frontmatter and organized findings:

**Frontmatter (YAML)**
```yaml
---
date: [ISO format with timezone]
git_commit: [Current commit hash]
branch: [Current branch name]
repository: [Repository name]
topic: "[Research topic/question]"
tags: [research, codebase, relevant-component-names]
status: complete
last_updated: [YYYY-MM-DD]
---
```

**Document Body**
- **Research Question**: The original query or area of investigation
- **Summary**: High-level overview of what was found, answering the research question factually
- **Detailed Findings**: Organized by component/area with:
  - Description of what exists with file:line references
  - How components connect to each other
  - Current implementation details (without evaluation)
- **Code References**: Bulleted list of key file paths with descriptions
- **Architecture Documentation**: Current patterns, conventions, and design implementations found
- **Open Questions**: Areas that need further investigation (if any)

#### Research Methodology

The Code Research Agent follows a systematic approach:

1. **Code Location**: Find WHERE files and components live
   - Search for files by topic/feature using relevant keywords
   - Identify directory patterns and naming conventions
   - Categorize findings (implementation, tests, config, docs, types)
   - Group files by purpose with full paths

2. **Code Analysis**: Understand HOW specific code works
   - Read files to understand logic and identify key functions
   - Trace data flow from entry to exit points
   - Map transformations, validations, and state changes
   - Document architectural patterns and integration points
   - Always include precise file:line references

3. **Code Pattern Finder**: Find examples of existing patterns
   - Locate similar implementations for reference
   - Extract reusable patterns and conventions
   - Provide concrete code examples with file:line references
   - Show multiple variations where they exist

#### GitHub Permalinks

When the commit is pushed or on the main branch, the document includes GitHub permalinks for permanent reference:
- Format: `https://github.com/{owner}/{repo}/blob/{commit}/{file}#L{line}`
- Ensures links remain valid even as code evolves
- **Note**: For private repositories, these links require authentication and will only be accessible to users with appropriate repository access.

#### Follow-up Research

If additional questions arise during planning, the document can be updated:
- Frontmatter updated with `last_updated` and `last_updated_note` fields
- New section added: `## Follow-up Research [timestamp]`
- Additional findings appended to maintain complete research history

#### Quality Standards

A well-formed Code Research document:
- **Is Factual**: Describes only what exists in the codebase today
- **Is Precise**: Includes exact file paths and line numbers for all claims
- **Is Comprehensive**: Covers all relevant components and their interactions
- **Is Organized**: Groups findings logically by component or area
- **Is Traceable**: Provides GitHub permalinks when available
- **Is Neutral**: Documents without critiquing or recommending changes

### ImplementationPlan.md

The **Implementation Plan** is a comprehensive technical specification that translates the high-level requirements from `Spec.md` into actionable, phased development work. Created through an interactive process between the Implementation Plan Agent and the developer, it serves as the definitive blueprint for the Implementation Stage.

**Purpose:** Bridge the gap between "what to build" (Spec) and "how to build it" (Implementation Phases), providing concrete technical guidance that Implementation Agents can execute without ambiguity.

**Location:** `/docs/agents/<target_branch>/ImplementationPlan.md`

**Dependencies:** Links to and builds upon `Spec.md`, `SpecResearch.md`, and `CodeResearch.md`.

#### Structure & Content

The Implementation Plan follows a standardized template that ensures completeness and actionability:

**Header & Overview**
- **Feature/Task Name**: Clear title matching the specification
- **Overview**: 1-2 sentence summary of what's being implemented and why
- **Current State Analysis**: What exists now, what's missing, key constraints discovered from research
- **Desired End State**: Testable specification of the final state with verification criteria

**Scope Management**
- **Key Discoveries**: Important findings from code research with specific `file:line` references
- **Implementation Approach**: High-level strategy and technical reasoning
- **What We're NOT Doing**: Explicit out-of-scope items to prevent scope creep

**Implementation Phases**
Each phase represents a discrete, reviewable chunk of work that:
- Can be developed on a dedicated branch (`<target_branch>_phase<N>`)
- Produces a standalone Phase PR
- Has clear success criteria (both automated and manual)
- Builds incrementally toward the desired end state

**Phase Structure:**
````markdown
## Phase N: [Descriptive Name]

### Overview
[What this phase accomplishes and why it's sequenced here]

### Changes Required:

#### 1. [Component/File Group]
**File**: `path/to/file.ext`
**Changes**: [Summary of changes]

```[language]
// Specific code to add/modify
```

### Success Criteria:

#### Automated Verification:
- [ ] Migration applies cleanly: `make migrate`
- [ ] Unit tests pass: `make test-component`
- [ ] Type checking passes: `npm run typecheck`
- [ ] Linting passes: `make lint`

#### Manual Verification:
- [ ] Feature works as expected when tested via UI
- [ ] Performance is acceptable under load
- [ ] No regressions in related features

### Status

Unimplemented
````

**Supporting Sections**
- **Testing Strategy**: Unit, integration, and manual testing approaches
- **Performance Considerations**: Any performance implications or optimizations
- **Migration Notes**: How to handle existing data/systems during transitions
- **References**: Links back to source artifacts and similar implementations

#### Success Criteria Philosophy

The plan distinguishes between two types of verification:

1. **Automated Verification**: Commands and checks that Implementation Agents can run independently
   - Build commands, test suites, linting, type checking
   - Specific file existence or content validation
   - API endpoint testing with curl/scripts

2. **Manual Verification**: Human-judgment tasks that require interactive testing
   - UI/UX functionality and user experience
   - Performance under realistic load conditions
   - Edge case handling and error scenarios
   - Cross-browser or cross-platform compatibility

This separation enables Implementation Agents to validate their work automatically while clearly identifying what requires human review.

#### Interactive Creation Process

The Implementation Plan Agent creates this document through a collaborative, iterative process:

1. **Context Gathering**: Reads all prerequisite artifacts completely and performs additional code research
2. **Design Exploration**: Presents multiple technical approaches with trade-offs for human decision
3. **Structure Development**: Proposes phase breakdown and sequencing for validation
4. **Detailed Writing**: Authors the complete plan with specific file paths, code examples, and measurable criteria
5. **Refinement**: Iterates based on feedback until all open questions are resolved

**Critical Requirement**: The final plan must be complete and actionable with zero open questions. If uncertainties arise during planning, the agent pauses to research or request clarification rather than proceeding with ambiguity.

#### Quality Standards

A well-formed Implementation Plan:
- **Is Specific**: Includes exact file paths, function names, and code snippets
- **Is Testable**: Every change has clear, measurable success criteria
- **Is Incremental**: Phases build logically and can be reviewed independently
- **Is Complete**: No technical decisions are deferred or left ambiguous
- **Is Traceable**: Links back to requirements and forward to expected outcomes

The Implementation Plan contains links to `Spec.md`, `SpecResearch.md`, and `CodeResearch.md`.

#### Phase Status Tracking

During implementation, before the Implementation Review Agent pushes changes, it updates the status section of the current phase to reflect progress. It appends any new status section as review iterations occur. It states that the phase is completed and adds any notes that can inform agents working on future phases. It also notes any review tasks for any specific code that reviewers should take a close look at and why.

The status section follows this format:

```markdown
### Status

**State:** Completed | In Progress | Blocked
**Completed:** YYYY-MM-DD
**PR:** #123
**Notes:** [Any relevant notes for future phases]
**Review Focus:** [Specific areas requiring careful review]
```

### Docs.md

The **Documentation** artifact captures all documentation updates made during the Documentation Stage. Created by the Documenter Agent, it serves as both a record of what was documented and a reference for reviewers validating documentation completeness.

**Purpose:** Ensure comprehensive documentation of the feature or task, including user-facing documentation, technical documentation, and any updates to existing documentation required by the changes.

**Location:** `/docs/agents/<target_branch>/Docs.md`

**Dependencies:** Built upon the completed implementation phases, `ImplementationPlan.md`, `Spec.md`, and all merged Phase PRs.

#### Core Principle: Complete Documentation Coverage

The Docs.md artifact ensures that all aspects of the feature are properly documented according to project standards and guidelines:

**What it DOES include:**
- Summary of all documentation changes made
- Links to updated documentation files in the repository
- User-facing documentation updates (if applicable)
- Technical documentation updates (API docs, architecture docs, etc.)
- Updated examples, tutorials, or guides
- Changes to README, CHANGELOG, or similar files
- Migration guides or upgrade notes (if applicable)
- References to relevant acceptance criteria from Spec.md

**What it does NOT include:**
- The actual documentation content (that lives in project docs)
- Code comments or docstrings (those are in the codebase)
- Implementation details (those are in the code and ImplementationPlan.md)

#### Structure & Content

The document follows a structured format to ensure comprehensive coverage:

**Header**
- **Feature/Task Name**: Title matching the specification and implementation plan
- **Documentation Overview**: Brief summary of what was documented and why

**Documentation Changes**

**User-Facing Documentation**
- List of files updated or created
- Summary of content changes
- Links to the updated documentation files

**Technical Documentation**
- API documentation updates
- Architecture or design documentation changes
- Configuration or deployment documentation updates
- Links to the updated documentation files

**Examples and Guides**
- New or updated code examples
- Tutorial or walkthrough updates
- Quick-start guide changes

**Project Metadata**
- README updates
- CHANGELOG entries
- Migration guides
- Upgrade notes

**Acceptance Criteria Mapping**
- Reference to each acceptance criterion from Spec.md
- Documentation that addresses or evidences each criterion
- Verification that all specified requirements are documented

**Review Checklist**
- Documentation follows project style guidelines
- All new features are documented
- All breaking changes are documented
- Examples are tested and working
- Links are valid and point to correct locations
- Documentation is clear and complete

#### Quality Standards

A well-formed Docs.md artifact:
- **Is Comprehensive**: Covers all user-facing and technical documentation needs
- **Is Traceable**: Maps back to acceptance criteria in Spec.md
- **Is Accurate**: Documentation matches actual implementation
- **Is Complete**: No gaps in documentation coverage
- **Is Consistent**: Follows project documentation standards and style
- **Is Verified**: All examples and code snippets are tested and working